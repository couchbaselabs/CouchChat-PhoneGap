(function(){var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var cached = require.cache[resolved];
    var res = cached? cached.exports : mod();
    return res;
};

require.paths = [];
require.modules = {};
require.cache = {};
require.extensions = [".js",".coffee",".json"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';
        
        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';
        
        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }
        
        var n = loadNodeModulesSync(x, y);
        if (n) return n;
        
        throw new Error("Cannot find module '" + x + "'");
        
        function loadAsFileSync (x) {
            x = path.normalize(x);
            if (require.modules[x]) {
                return x;
            }
            
            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }
        
        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = path.normalize(x + '/package.json');
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }
            
            return loadAsFileSync(x + '/index');
        }
        
        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }
            
            var m = loadAsFileSync(x);
            if (m) return m;
        }
        
        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');
            
            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }
            
            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);
    
    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key);
        return res;
    })(require.modules);
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

(function () {
    var process = {};
    var global = typeof window !== 'undefined' ? window : {};
    var definedProcess = false;
    
    require.define = function (filename, fn) {
        if (!definedProcess && require.modules.__browserify_process) {
            process = require.modules.__browserify_process();
            definedProcess = true;
        }
        
        var dirname = require._core[filename]
            ? ''
            : require.modules.path().dirname(filename)
        ;
        
        var require_ = function (file) {
            var requiredModule = require(file, dirname);
            var cached = require.cache[require.resolve(file, dirname)];

            if (cached && cached.parent === null) {
                cached.parent = module_;
            }

            return requiredModule;
        };
        require_.resolve = function (name) {
            return require.resolve(name, dirname);
        };
        require_.modules = require.modules;
        require_.define = require.define;
        require_.cache = require.cache;
        var module_ = {
            id : filename,
            filename: filename,
            exports : {},
            loaded : false,
            parent: null
        };
        
        require.modules[filename] = function () {
            require.cache[filename] = module_;
            fn.call(
                module_.exports,
                require_,
                module_,
                module_.exports,
                dirname,
                filename,
                process,
                global
            );
            module_.loaded = true;
            return module_.exports;
        };
    };
})();


require.define("path",Function(['require','module','exports','__dirname','__filename','process','global'],"function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var dir = splitPathRe.exec(path)[1] || '';\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[2] || '';\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[3] || '';\n};\n\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\n//@ sourceURL=path"
));

require.define("__browserify_process",Function(['require','module','exports','__dirname','__filename','process','global'],"var process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n        && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n        && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            if (ev.source === window && ev.data === 'browserify-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('browserify-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    if (name === 'evals') return (require)('vm')\n    else throw new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    process.cwd = function () { return cwd };\n    process.chdir = function (dir) {\n        if (!path) path = require('path');\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n\n//@ sourceURL=__browserify_process"
));

require.define("/node_modules/mustache/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./mustache.js\"}\n//@ sourceURL=/node_modules/mustache/package.json"
));

require.define("/node_modules/mustache/mustache.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*!\n * mustache.js - Logic-less {{mustache}} templates with JavaScript\n * http://github.com/janl/mustache.js\n */\n\n/*global define: false*/\n\nvar Mustache;\n\n(function (exports) {\n  if (typeof module !== \"undefined\" && module.exports) {\n    module.exports = exports; // CommonJS\n  } else if (typeof define === \"function\") {\n    define(exports); // AMD\n  } else {\n    Mustache = exports; // <script>\n  }\n}((function () {\n\n  var exports = {};\n\n  exports.name = \"mustache.js\";\n  exports.version = \"0.7.1\";\n  exports.tags = [\"{{\", \"}}\"];\n\n  exports.Scanner = Scanner;\n  exports.Context = Context;\n  exports.Writer = Writer;\n\n  var whiteRe = /\\s*/;\n  var spaceRe = /\\s+/;\n  var nonSpaceRe = /\\S/;\n  var eqRe = /\\s*=/;\n  var curlyRe = /\\s*\\}/;\n  var tagRe = /#|\\^|\\/|>|\\{|&|=|!/;\n\n  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577\n  // See https://github.com/janl/mustache.js/issues/189\n  function testRe(re, string) {\n    return RegExp.prototype.test.call(re, string);\n  }\n\n  function isWhitespace(string) {\n    return !testRe(nonSpaceRe, string);\n  }\n\n  var isArray = Array.isArray || function (obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  };\n\n  function escapeRe(string) {\n    return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, \"\\\\$&\");\n  }\n\n  var entityMap = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    \"/\": '&#x2F;'\n  };\n\n  function escapeHtml(string) {\n    return String(string).replace(/[&<>\"'\\/]/g, function (s) {\n      return entityMap[s];\n    });\n  }\n\n  // Export the escaping function so that the user may override it.\n  // See https://github.com/janl/mustache.js/issues/244\n  exports.escape = escapeHtml;\n\n  function Scanner(string) {\n    this.string = string;\n    this.tail = string;\n    this.pos = 0;\n  }\n\n  /**\n   * Returns `true` if the tail is empty (end of string).\n   */\n  Scanner.prototype.eos = function () {\n    return this.tail === \"\";\n  };\n\n  /**\n   * Tries to match the given regular expression at the current position.\n   * Returns the matched text if it can match, the empty string otherwise.\n   */\n  Scanner.prototype.scan = function (re) {\n    var match = this.tail.match(re);\n\n    if (match && match.index === 0) {\n      this.tail = this.tail.substring(match[0].length);\n      this.pos += match[0].length;\n      return match[0];\n    }\n\n    return \"\";\n  };\n\n  /**\n   * Skips all text until the given regular expression can be matched. Returns\n   * the skipped string, which is the entire tail if no match can be made.\n   */\n  Scanner.prototype.scanUntil = function (re) {\n    var match, pos = this.tail.search(re);\n\n    switch (pos) {\n    case -1:\n      match = this.tail;\n      this.pos += this.tail.length;\n      this.tail = \"\";\n      break;\n    case 0:\n      match = \"\";\n      break;\n    default:\n      match = this.tail.substring(0, pos);\n      this.tail = this.tail.substring(pos);\n      this.pos += pos;\n    }\n\n    return match;\n  };\n\n  function Context(view, parent) {\n    this.view = view;\n    this.parent = parent;\n    this.clearCache();\n  }\n\n  Context.make = function (view) {\n    return (view instanceof Context) ? view : new Context(view);\n  };\n\n  Context.prototype.clearCache = function () {\n    this._cache = {};\n  };\n\n  Context.prototype.push = function (view) {\n    return new Context(view, this);\n  };\n\n  Context.prototype.lookup = function (name) {\n    var value = this._cache[name];\n\n    if (!value) {\n      if (name === \".\") {\n        value = this.view;\n      } else {\n        var context = this;\n\n        while (context) {\n          if (name.indexOf(\".\") > 0) {\n            var names = name.split(\".\"), i = 0;\n\n            value = context.view;\n\n            while (value && i < names.length) {\n              value = value[names[i++]];\n            }\n          } else {\n            value = context.view[name];\n          }\n\n          if (value != null) {\n            break;\n          }\n\n          context = context.parent;\n        }\n      }\n\n      this._cache[name] = value;\n    }\n\n    if (typeof value === \"function\") {\n      value = value.call(this.view);\n    }\n\n    return value;\n  };\n\n  function Writer() {\n    this.clearCache();\n  }\n\n  Writer.prototype.clearCache = function () {\n    this._cache = {};\n    this._partialCache = {};\n  };\n\n  Writer.prototype.compile = function (template, tags) {\n    var fn = this._cache[template];\n\n    if (!fn) {\n      var tokens = exports.parse(template, tags);\n      fn = this._cache[template] = this.compileTokens(tokens, template);\n    }\n\n    return fn;\n  };\n\n  Writer.prototype.compilePartial = function (name, template, tags) {\n    var fn = this.compile(template, tags);\n    this._partialCache[name] = fn;\n    return fn;\n  };\n\n  Writer.prototype.compileTokens = function (tokens, template) {\n    var fn = compileTokens(tokens);\n    var self = this;\n\n    return function (view, partials) {\n      if (partials) {\n        if (typeof partials === \"function\") {\n          self._loadPartial = partials;\n        } else {\n          for (var name in partials) {\n            self.compilePartial(name, partials[name]);\n          }\n        }\n      }\n\n      return fn(self, Context.make(view), template);\n    };\n  };\n\n  Writer.prototype.render = function (template, view, partials) {\n    return this.compile(template)(view, partials);\n  };\n\n  Writer.prototype._section = function (name, context, text, callback) {\n    var value = context.lookup(name);\n\n    switch (typeof value) {\n    case \"object\":\n      if (isArray(value)) {\n        var buffer = \"\";\n\n        for (var i = 0, len = value.length; i < len; ++i) {\n          buffer += callback(this, context.push(value[i]));\n        }\n\n        return buffer;\n      }\n\n      return value ? callback(this, context.push(value)) : \"\";\n    case \"function\":\n      var self = this;\n      var scopedRender = function (template) {\n        return self.render(template, context);\n      };\n\n      var result = value.call(context.view, text, scopedRender);\n      return result != null ? result : \"\";\n    default:\n      if (value) {\n        return callback(this, context);\n      }\n    }\n\n    return \"\";\n  };\n\n  Writer.prototype._inverted = function (name, context, callback) {\n    var value = context.lookup(name);\n\n    // Use JavaScript's definition of falsy. Include empty arrays.\n    // See https://github.com/janl/mustache.js/issues/186\n    if (!value || (isArray(value) && value.length === 0)) {\n      return callback(this, context);\n    }\n\n    return \"\";\n  };\n\n  Writer.prototype._partial = function (name, context) {\n    if (!(name in this._partialCache) && this._loadPartial) {\n      this.compilePartial(name, this._loadPartial(name));\n    }\n\n    var fn = this._partialCache[name];\n\n    return fn ? fn(context) : \"\";\n  };\n\n  Writer.prototype._name = function (name, context) {\n    var value = context.lookup(name);\n\n    if (typeof value === \"function\") {\n      value = value.call(context.view);\n    }\n\n    return (value == null) ? \"\" : String(value);\n  };\n\n  Writer.prototype._escaped = function (name, context) {\n    return exports.escape(this._name(name, context));\n  };\n\n  /**\n   * Calculates the bounds of the section represented by the given `token` in\n   * the original template by drilling down into nested sections to find the\n   * last token that is part of that section. Returns an array of [start, end].\n   */\n  function sectionBounds(token) {\n    var start = token[3];\n    var end = start;\n\n    var tokens;\n    while ((tokens = token[4]) && tokens.length) {\n      token = tokens[tokens.length - 1];\n      end = token[3];\n    }\n\n    return [start, end];\n  }\n\n  /**\n   * Low-level function that compiles the given `tokens` into a function\n   * that accepts three arguments: a Writer, a Context, and the template.\n   */\n  function compileTokens(tokens) {\n    var subRenders = {};\n\n    function subRender(i, tokens, template) {\n      if (!subRenders[i]) {\n        var fn = compileTokens(tokens);\n        subRenders[i] = function (writer, context) {\n          return fn(writer, context, template);\n        };\n      }\n\n      return subRenders[i];\n    }\n\n    return function (writer, context, template) {\n      var buffer = \"\";\n      var token, sectionText;\n\n      for (var i = 0, len = tokens.length; i < len; ++i) {\n        token = tokens[i];\n\n        switch (token[0]) {\n        case \"#\":\n          sectionText = template.slice.apply(template, sectionBounds(token));\n          buffer += writer._section(token[1], context, sectionText, subRender(i, token[4], template));\n          break;\n        case \"^\":\n          buffer += writer._inverted(token[1], context, subRender(i, token[4], template));\n          break;\n        case \">\":\n          buffer += writer._partial(token[1], context);\n          break;\n        case \"&\":\n          buffer += writer._name(token[1], context);\n          break;\n        case \"name\":\n          buffer += writer._escaped(token[1], context);\n          break;\n        case \"text\":\n          buffer += token[1];\n          break;\n        }\n      }\n\n      return buffer;\n    };\n  }\n\n  /**\n   * Forms the given array of `tokens` into a nested tree structure where\n   * tokens that represent a section have a fifth item: an array that contains\n   * all tokens in that section.\n   */\n  function nestTokens(tokens) {\n    var tree = [];\n    var collector = tree;\n    var sections = [];\n    var token, section;\n\n    for (var i = 0; i < tokens.length; ++i) {\n      token = tokens[i];\n\n      switch (token[0]) {\n      case \"#\":\n      case \"^\":\n        token[4] = [];\n        sections.push(token);\n        collector.push(token);\n        collector = token[4];\n        break;\n      case \"/\":\n        if (sections.length === 0) {\n          throw new Error(\"Unopened section: \" + token[1]);\n        }\n\n        section = sections.pop();\n\n        if (section[1] !== token[1]) {\n          throw new Error(\"Unclosed section: \" + section[1]);\n        }\n\n        if (sections.length > 0) {\n          collector = sections[sections.length - 1][4];\n        } else {\n          collector = tree;\n        }\n        break;\n      default:\n        collector.push(token);\n      }\n    }\n\n    // Make sure there were no open sections when we're done.\n    section = sections.pop();\n\n    if (section) {\n      throw new Error(\"Unclosed section: \" + section[1]);\n    }\n\n    return tree;\n  }\n\n  /**\n   * Combines the values of consecutive text tokens in the given `tokens` array\n   * to a single token.\n   */\n  function squashTokens(tokens) {\n    var token, lastToken, squashedTokens = [];\n\n    for (var i = 0; i < tokens.length; ++i) {\n      token = tokens[i];\n\n      if (lastToken && lastToken[0] === \"text\" && token[0] === \"text\") {\n        lastToken[1] += token[1];\n        lastToken[3] = token[3];\n      } else {\n        lastToken = token;\n        squashedTokens.push(token);\n      }\n    }\n\n    return squashedTokens;\n  }\n\n  function escapeTags(tags) {\n    if (tags.length !== 2) {\n      throw new Error(\"Invalid tags: \" + tags.join(\" \"));\n    }\n\n    return [\n      new RegExp(escapeRe(tags[0]) + \"\\\\s*\"),\n      new RegExp(\"\\\\s*\" + escapeRe(tags[1]))\n    ];\n  }\n\n  /**\n   * Breaks up the given `template` string into a tree of token objects. If\n   * `tags` is given here it must be an array with two string values: the\n   * opening and closing tags used in the template (e.g. [\"<%\", \"%>\"]). Of\n   * course, the default is to use mustaches (i.e. Mustache.tags).\n   */\n  exports.parse = function (template, tags) {\n    template = template || '';\n    tags = tags || exports.tags;\n\n    var tagRes = escapeTags(tags);\n    var scanner = new Scanner(template);\n\n    var tokens = [],      // Buffer to hold the tokens\n        spaces = [],      // Indices of whitespace tokens on the current line\n        hasTag = false,   // Is there a {{tag}} on the current line?\n        nonSpace = false; // Is there a non-space char on the current line?\n\n    // Strips all whitespace tokens array for the current line\n    // if there was a {{#tag}} on it and otherwise only space.\n    function stripSpace() {\n      if (hasTag && !nonSpace) {\n        while (spaces.length) {\n          tokens.splice(spaces.pop(), 1);\n        }\n      } else {\n        spaces = [];\n      }\n\n      hasTag = false;\n      nonSpace = false;\n    }\n\n    var start, type, value, chr;\n\n    while (!scanner.eos()) {\n      start = scanner.pos;\n      value = scanner.scanUntil(tagRes[0]);\n\n      if (value) {\n        for (var i = 0, len = value.length; i < len; ++i) {\n          chr = value.charAt(i);\n\n          if (isWhitespace(chr)) {\n            spaces.push(tokens.length);\n          } else {\n            nonSpace = true;\n          }\n\n          tokens.push([\"text\", chr, start, start + 1]);\n          start += 1;\n\n          if (chr === \"\\n\") {\n            stripSpace(); // Check for whitespace on the current line.\n          }\n        }\n      }\n\n      start = scanner.pos;\n\n      // Match the opening tag.\n      if (!scanner.scan(tagRes[0])) {\n        break;\n      }\n\n      hasTag = true;\n      type = scanner.scan(tagRe) || \"name\";\n\n      // Skip any whitespace between tag and value.\n      scanner.scan(whiteRe);\n\n      // Extract the tag value.\n      if (type === \"=\") {\n        value = scanner.scanUntil(eqRe);\n        scanner.scan(eqRe);\n        scanner.scanUntil(tagRes[1]);\n      } else if (type === \"{\") {\n        var closeRe = new RegExp(\"\\\\s*\" + escapeRe(\"}\" + tags[1]));\n        value = scanner.scanUntil(closeRe);\n        scanner.scan(curlyRe);\n        scanner.scanUntil(tagRes[1]);\n        type = \"&\";\n      } else {\n        value = scanner.scanUntil(tagRes[1]);\n      }\n\n      // Match the closing tag.\n      if (!scanner.scan(tagRes[1])) {\n        throw new Error(\"Unclosed tag at \" + scanner.pos);\n      }\n\n      tokens.push([type, value, start, scanner.pos]);\n\n      if (type === \"name\" || type === \"{\" || type === \"&\") {\n        nonSpace = true;\n      }\n\n      // Set the tags for the next time around.\n      if (type === \"=\") {\n        tags = value.split(spaceRe);\n        tagRes = escapeTags(tags);\n      }\n    }\n\n    tokens = squashTokens(tokens);\n\n    return nestTokens(tokens);\n  };\n\n  // The high-level clearCache, compile, compilePartial, and render functions\n  // use this default writer.\n  var _writer = new Writer();\n\n  /**\n   * Clears all cached templates and partials in the default writer.\n   */\n  exports.clearCache = function () {\n    return _writer.clearCache();\n  };\n\n  /**\n   * Compiles the given `template` to a reusable function using the default\n   * writer.\n   */\n  exports.compile = function (template, tags) {\n    return _writer.compile(template, tags);\n  };\n\n  /**\n   * Compiles the partial with the given `name` and `template` to a reusable\n   * function using the default writer.\n   */\n  exports.compilePartial = function (name, template, tags) {\n    return _writer.compilePartial(name, template, tags);\n  };\n\n  /**\n   * Compiles the given array of tokens (the output of a parse) to a reusable\n   * function using the default writer.\n   */\n  exports.compileTokens = function (tokens, template) {\n    return _writer.compileTokens(tokens, template);\n  };\n\n  /**\n   * Renders the `template` with the given `view` and `partials` using the\n   * default writer.\n   */\n  exports.render = function (template, view, partials) {\n    return _writer.render(template, view, partials);\n  };\n\n  // This is here for backwards compatibility with 0.4.x.\n  exports.to_html = function (template, view, partials, send) {\n    var result = exports.render(template, view, partials);\n\n    if (typeof send === \"function\") {\n      send(result);\n    } else {\n      return result;\n    }\n  };\n\n  return exports;\n\n}())));\n\n//@ sourceURL=/node_modules/mustache/mustache.js"
));

require.define("/node_modules/coax/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"lib/coax\"}\n//@ sourceURL=/node_modules/coax/package.json"
));

require.define("/node_modules/coax/node_modules/pax/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"lib/pax\"}\n//@ sourceURL=/node_modules/coax/node_modules/pax/package.json"
));

require.define("/node_modules/coax/node_modules/pax/lib/pax.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*\n * pax\n * https://github.com/jchris/pax\n *\n * Copyright (c) 2013 Chris Anderson\n * Licensed under the APL license.\n */\n\nfunction objToQuery(q) {\n  var k, ks = Object.keys(q), v, query = [];\n  for (k = 0; k < ks.length; k++) {\n    v = q[ks[k]];\n    query.push(encodeURIComponent(ks[k])+'='+encodeURIComponent(v.toString()));\n  }\n  return query.join('&');\n}\n\n// if there is an object in the new path,\n// pluck it out and put it on the pax instance;\n\nfunction processPath(path) {\n  var query;\n  if (path && path.pop && path.length) {\n    if (typeof path[path.length-1] === 'object') {\n      path.query = path.pop();\n    }\n    return path;\n  } else if (typeof path === \"object\") { // options\n    var empty = [];\n    empty.query = path;\n    return empty;\n  } else if (path) { // string\n    return [path];\n  } else {\n    return [];\n  }\n}\n\nfunction merge(target, source) {\n  for (var key in source) {\n    if (source.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\n\nfunction mergePaths(path, newPath) {\n  var k, merged = path.concat(newPath);\n  merged.methods = {};\n  if (path.query)  {\n    merged.query = merge({}, path.query);\n  }\n  if (newPath.query) {\n    merged.query = merge(merged.query || {}, newPath.query);\n  }\n  if (typeof path.getQuery !== 'undefined') {\n    merged.getQuery = path.getQuery;\n  }\n  for (k in path.methods) {\n    merged.methods[k] = path.methods[k];\n  }\n\n  // if (typeof newPath.getQuery !== 'undefined') {\n  //   merged.getQuery = newPath.getQuery;\n  // }\n  return merged;\n}\n\nfunction makeToString(path) {\n  var first = true,\n  encoded = path.map(function(p) {\n    if (first) {\n      first = false;\n      if (/^http/.test(p)) {\n        if (/\\/$/.test(p)) {\n          return p.substring(0,p.length-1);\n        } else {\n          return p;\n        }\n      }\n    }\n    return encodeURIComponent(p);\n  });\n\n  return function() {\n    if (path.query) {\n      var qobj;\n      if (path.getQuery || this.getQuery) {\n        qobj = (path.getQuery || this.getQuery)(path.query);\n      } else {\n        qobj = path.query;\n      }\n      return encoded.join('/') + '?' + objToQuery(qobj);\n    } else {\n      return encoded.join('/');\n    }\n  };\n}\n\nfunction extenderizer(path) {\n  path.methods = path.methods || {};\n  return function(name, fun) {\n    path.methods[name] = fun;\n    this[name] = fun;\n  };\n}\n\nfunction addExtensions(pax, path) {\n  var k;\n  for (k in path.methods) {\n    pax[k] = path.methods[k];\n  }\n}\n\nvar growPax;\n\nfunction makeNextPathFun(path) {\n  var nextPax = function(nextPath) {\n    // console.log(\"nextPax\",nextPax);\n    if (typeof nextPax.getQuery !== 'undefined') {path.getQuery = nextPax.getQuery;}\n    if (arguments.length > 1) {\n      return growPax(path, [].map.call(arguments,function(arg){return arg;}));\n    } else {\n      return growPax(path, nextPath);\n    }\n  };\n  addExtensions(nextPax, path);\n  nextPax.extend = extenderizer(path);\n  // console.log([\"pax\", path, path.query]);\n  nextPax.toString = makeToString(path);\n  // console.log([\"paxs\", nextPax.toString()]);\n  return nextPax;\n}\n\nfunction growPax(path, newPath) {\n  newPath = processPath(newPath);\n  path = mergePaths(path, newPath);\n  return makeNextPathFun(path);\n}\n\nmodule.exports = makeNextPathFun([]);\n\n\n//@ sourceURL=/node_modules/coax/node_modules/pax/lib/pax.js"
));

require.define("/node_modules/coax/node_modules/hoax/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"lib/hoax\",\"browserify\":\"lib/hoax-browserify\"}\n//@ sourceURL=/node_modules/coax/node_modules/hoax/package.json"
));

require.define("/node_modules/coax/node_modules/hoax/lib/hoax-browserify.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var core = require(\"./hoax-core\"),\n  request = require(\"browser-request\");\n\nrequest.log.debug = function() {};\n\nmodule.exports = core(request);\n\n//@ sourceURL=/node_modules/coax/node_modules/hoax/lib/hoax-browserify.js"
));

require.define("/node_modules/coax/node_modules/hoax/lib/hoax-core.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*\n * hoax\n * https://github.com/jchris/hoax\n *\n * Copyright (c) 2013 Chris Anderson\n * Licensed under the Apache license.\n */\n\nmodule.exports = function(request) {\n  var pax = require(\"pax\");\n\n  function makeHoaxCallback(cb, verb) {\n    return function(err, res, body){\n      // console.log(\"hoax cb\", verb||\"get\", err, res.statusCode, body);\n      if (err && err !== \"error\") {\n        cb(err, res, body);\n      } else {\n        if (res.statusCode >= 400 || err === \"error\") {\n          cb(body || res.statusCode, res);\n        } else {\n          cb(null, body);\n        }\n      }\n    };\n  }\n\n  function processArguments(myPax, urlOrOpts, data, cb, verb) {\n    var opts = {}, newPax = myPax;\n    if (typeof urlOrOpts === 'function') {\n      cb = urlOrOpts;\n      data = null;\n      urlOrOpts = null;\n    } else {\n      if (urlOrOpts.uri || urlOrOpts.url) {\n        newPax = myPax(urlOrOpts.uri || urlOrOpts.url);\n      } else {\n        if (typeof data === 'function') {\n          // we have only 2 args\n          // the first is data if it is not an array\n          // and the verb is put or post\n          cb = data;\n          data = null;\n          if ((verb === \"put\" || verb === \"post\") &&\n            (typeof urlOrOpts !== \"string\" &&\n              Object.prototype.toString.call(urlOrOpts) !== '[object Array]')) {\n              data = urlOrOpts;\n          } else {\n            newPax = myPax(urlOrOpts);\n          }\n        } else {\n          newPax = myPax(urlOrOpts);\n        }\n      }\n    }\n    opts.headers = {'content-type': 'application/json'};\n    opts.json = true;\n    opts.uri = newPax.toString();\n    if (data) {\n      opts.body = JSON.stringify(data);\n    }\n    return [opts, cb, newPax];\n  }\n\n  function extenderizer(oldHoax) {\n    return function(name, fun) {\n      this.methods = this.methods || {};\n      this.methods[name] = fun;\n      this[name] = fun;\n    };\n  }\n\n  function addExtensions(newHoax, oldHoax) {\n    if (oldHoax && oldHoax.methods) {\n      var k;\n      for (k in oldHoax.methods) {\n        newHoax[k] = oldHoax.methods[k];\n      }\n    }\n  }\n\n  function makeHoax(myPax, verb, oldHoax) {\n    var newHoax = function(opts, data, xcb) {\n      var args = processArguments(myPax, opts, data, xcb, verb),\n        reqOpts = args[0], // includes uri, body\n        cb = args[1],\n        newPax = args[2];\n      if (cb) {\n        // console.log([\"hoax\", verb||\"get\", reqOpts]);\n        if (verb) {\n          return request[verb](reqOpts, makeHoaxCallback(cb, verb));\n        } else {\n          return request(reqOpts, makeHoaxCallback(cb));\n        }\n      } else {\n        // console.log(\"new hoax\", newPax);\n        return makeHoax(newPax, verb, newHoax);\n      }\n    };\n    if (!verb) {\n      \"get put post head del\".split(\" \").forEach(function(v){\n        newHoax[v] = makeHoax(myPax, v, newHoax);\n      });\n    }\n    addExtensions(newHoax, oldHoax);\n    // should this be extenderizer(newHoax) ?\n    newHoax.extend = extenderizer(oldHoax);\n    newHoax.pax = myPax;\n    return newHoax;\n  }\n\n  var Hoax = makeHoax(pax());\n  Hoax.makeHoax = makeHoax;\n\n  return Hoax;\n};\n\n\n//@ sourceURL=/node_modules/coax/node_modules/hoax/lib/hoax-core.js"
));

require.define("/node_modules/coax/node_modules/hoax/node_modules/browser-request/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"browserify\":\"./dist/ender/request.js\"}\n//@ sourceURL=/node_modules/coax/node_modules/hoax/node_modules/browser-request/package.json"
));

require.define("/node_modules/coax/node_modules/hoax/node_modules/browser-request/dist/ender/request.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Browser Request\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar xmlhttprequest = require('./xmlhttprequest')\nif(!xmlhttprequest || typeof xmlhttprequest !== 'object')\n  throw new Error('Could not find ./xmlhttprequest')\n\nvar XHR = xmlhttprequest.XMLHttpRequest\nif(!XHR)\n  throw new Error('Bad xmlhttprequest.XMLHttpRequest')\nif(! ('_object' in (new XHR)))\n  throw new Error('This is not portable XMLHttpRequest')\n\nmodule.exports = request\nrequest.XMLHttpRequest = XHR\nrequest.log = getLogger()\n\nvar DEFAULT_TIMEOUT = 3 * 60 * 1000 // 3 minutes\n\n//\n// request\n//\n\nfunction request(options, callback) {\n  // The entry-point to the API: prep the options object and pass the real work to run_xhr.\n  if(typeof callback !== 'function')\n    throw new Error('Bad callback given: ' + callback)\n\n  if(!options)\n    throw new Error('No options given')\n\n  var options_onResponse = options.onResponse; // Save this for later.\n\n  if(typeof options === 'string')\n    options = {'uri':options};\n  else\n    options = JSON.parse(JSON.stringify(options)); // Use a duplicate for mutating.\n\n  options.onResponse = options_onResponse // And put it back.\n\n  if(options.url) {\n    options.uri = options.url;\n    delete options.url;\n  }\n\n  if(!options.uri && options.uri !== \"\")\n    throw new Error(\"options.uri is a required argument\");\n\n  if(typeof options.uri != \"string\")\n    throw new Error(\"options.uri must be a string\");\n\n  var unsupported_options = ['proxy', '_redirectsFollowed', 'maxRedirects', 'followRedirect']\n  for (var i = 0; i < unsupported_options.length; i++)\n    if(options[ unsupported_options[i] ])\n      throw new Error(\"options.\" + unsupported_options[i] + \" is not supported\")\n\n  options.callback = callback\n  options.method = options.method || 'GET';\n  options.headers = options.headers || {};\n  options.body    = options.body || null\n  options.timeout = options.timeout || request.DEFAULT_TIMEOUT\n\n  if(options.headers.host)\n    throw new Error(\"Options.headers.host is not supported\");\n\n  if(options.json) {\n    options.headers.accept = options.headers.accept || 'application/json'\n    if(options.method !== 'GET')\n      options.headers['content-type'] = 'application/json'\n\n    if(typeof options.json !== 'boolean')\n      options.body = JSON.stringify(options.json)\n    else if(typeof options.body !== 'string')\n      options.body = JSON.stringify(options.body)\n  }\n\n  // If onResponse is boolean true, call back immediately when the response is known,\n  // not when the full request is complete.\n  options.onResponse = options.onResponse || noop\n  if(options.onResponse === true) {\n    options.onResponse = callback\n    options.callback = noop\n  }\n\n  // XXX Browsers do not like this.\n  //if(options.body)\n  //  options.headers['content-length'] = options.body.length;\n\n  // HTTP basic authentication\n  if(!options.headers.authorization && options.auth)\n    options.headers.authorization = 'Basic ' + b64_enc(options.auth.username + ':' + options.auth.password);\n\n  return run_xhr(options)\n}\n\nvar req_seq = 0\nfunction run_xhr(options) {\n  var xhr = new XHR\n    , timed_out = false\n    , is_cors = is_crossDomain(options.uri)\n    , supports_cors = ('withCredentials' in xhr._object)\n\n  req_seq += 1\n  xhr.seq_id = req_seq\n  xhr.id = req_seq + ': ' + options.method + ' ' + options.uri\n  xhr._id = xhr.id // I know I will type \"_id\" from habit all the time.\n\n  if(is_cors && !supports_cors) {\n    var cors_err = new Error('Browser does not support cross-origin request: ' + options.uri)\n    cors_err.cors = 'unsupported'\n    return options.callback(cors_err, xhr)\n  }\n\n  xhr.timeoutTimer = setTimeout(too_late, options.timeout)\n  function too_late() {\n    timed_out = true\n    var er = new Error('ETIMEDOUT')\n    er.code = 'ETIMEDOUT'\n    er.duration = options.timeout\n\n    request.log.error('Timeout', { 'id':xhr._id, 'milliseconds':options.timeout })\n    return options.callback(er, xhr)\n  }\n\n  // Some states can be skipped over, so remember what is still incomplete.\n  var did = {'response':false, 'loading':false, 'end':false}\n\n  xhr.onreadystatechange = on_state_change\n  xhr.open(options.method, options.uri, true) // asynchronous\n  if(is_cors)\n    xhr._object.withCredentials = !! options.withCredentials\n  xhr.send(options.body)\n  return xhr\n\n  function on_state_change(event) {\n    if(timed_out)\n      return request.log.debug('Ignoring timed out state change', {'state':xhr.readyState, 'id':xhr.id})\n\n    request.log.debug('State change', {'state':xhr.readyState, 'id':xhr.id, 'timed_out':timed_out})\n\n    if(xhr.readyState === XHR.OPENED) {\n      request.log.debug('Request started', {'id':xhr.id})\n      for (var key in options.headers)\n        xhr.setRequestHeader(key, options.headers[key])\n    }\n\n    else if(xhr.readyState === XHR.HEADERS_RECEIVED)\n      on_response()\n\n    else if(xhr.readyState === XHR.LOADING) {\n      on_response()\n      on_loading()\n    }\n\n    else if(xhr.readyState === XHR.DONE) {\n      on_response()\n      on_loading()\n      on_end()\n    }\n  }\n\n  function on_response() {\n    if(did.response)\n      return\n\n    did.response = true\n    request.log.debug('Got response', {'id':xhr.id, 'status':xhr.status})\n    clearTimeout(xhr.timeoutTimer)\n    xhr.statusCode = xhr.status // Node request compatibility\n\n    // Detect failed CORS requests.\n    if(is_cors && xhr.statusCode == 0) {\n      var cors_err = new Error('CORS request rejected: ' + options.uri)\n      cors_err.cors = 'rejected'\n\n      // Do not process this request further.\n      did.loading = true\n      did.end = true\n\n      return options.callback(cors_err, xhr)\n    }\n\n    options.onResponse(null, xhr)\n  }\n\n  function on_loading() {\n    if(did.loading)\n      return\n\n    did.loading = true\n    request.log.debug('Response body loading', {'id':xhr.id})\n    // TODO: Maybe simulate \"data\" events by watching xhr.responseText\n  }\n\n  function on_end() {\n    if(did.end)\n      return\n\n    did.end = true\n    request.log.debug('Request done', {'id':xhr.id})\n\n    xhr.body = xhr.responseText\n    if(options.json) {\n      try        { xhr.body = JSON.parse(xhr.responseText) }\n      catch (er) { return options.callback(er, xhr)        }\n    }\n\n    options.callback(null, xhr, xhr.body)\n  }\n\n} // request\n\nrequest.withCredentials = false;\nrequest.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;\n\n//\n// HTTP method shortcuts\n//\n\nvar shortcuts = [ 'get', 'put', 'post', 'head' ];\nshortcuts.forEach(function(shortcut) {\n  var method = shortcut.toUpperCase();\n  var func   = shortcut.toLowerCase();\n\n  request[func] = function(opts) {\n    if(typeof opts === 'string')\n      opts = {'method':method, 'uri':opts};\n    else {\n      opts = JSON.parse(JSON.stringify(opts));\n      opts.method = method;\n    }\n\n    var args = [opts].concat(Array.prototype.slice.apply(arguments, [1]));\n    return request.apply(this, args);\n  }\n})\n\n//\n// CouchDB shortcut\n//\n\nrequest.couch = function(options, callback) {\n  if(typeof options === 'string')\n    options = {'uri':options}\n\n  // Just use the request API to do JSON.\n  options.json = true\n  if(options.body)\n    options.json = options.body\n  delete options.body\n\n  callback = callback || noop\n\n  var xhr = request(options, couch_handler)\n  return xhr\n\n  function couch_handler(er, resp, body) {\n    if(er)\n      return callback(er, resp, body)\n\n    if((resp.statusCode < 200 || resp.statusCode > 299) && body.error) {\n      // The body is a Couch JSON object indicating the error.\n      er = new Error('CouchDB error: ' + (body.error.reason || body.error.error))\n      for (var key in body)\n        er[key] = body[key]\n      return callback(er, resp, body);\n    }\n\n    return callback(er, resp, body);\n  }\n}\n\n//\n// Utility\n//\n\nfunction noop() {}\n\nfunction getLogger() {\n  var logger = {}\n    , levels = ['trace', 'debug', 'info', 'warn', 'error']\n    , level, i\n\n  for(i = 0; i < levels.length; i++) {\n    level = levels[i]\n\n    logger[level] = noop\n    if(typeof console !== 'undefined' && console && console[level])\n      logger[level] = formatted(console, level)\n  }\n\n  return logger\n}\n\nfunction formatted(obj, method) {\n  return formatted_logger\n\n  function formatted_logger(str, context) {\n    if(typeof context === 'object')\n      str += ' ' + JSON.stringify(context)\n\n    return obj[method].call(obj, str)\n  }\n}\n\n// Return whether a URL is a cross-domain request.\nfunction is_crossDomain(url) {\n  var rurl = /^([\\w\\+\\.\\-]+:)(?:\\/\\/([^\\/?#:]*)(?::(\\d+))?)?/\n\n  // jQuery #8138, IE may throw an exception when accessing\n  // a field from window.location if document.domain has been set\n  var ajaxLocation\n  try { ajaxLocation = location.href }\n  catch (e) {\n    // Use the href attribute of an A element since IE will modify it given document.location\n    ajaxLocation = document.createElement( \"a\" );\n    ajaxLocation.href = \"\";\n    ajaxLocation = ajaxLocation.href;\n  }\n\n  var ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || []\n    , parts = rurl.exec(url.toLowerCase() )\n\n  var result = !!(\n    parts &&\n    (  parts[1] != ajaxLocParts[1]\n    || parts[2] != ajaxLocParts[2]\n    || (parts[3] || (parts[1] === \"http:\" ? 80 : 443)) != (ajaxLocParts[3] || (ajaxLocParts[1] === \"http:\" ? 80 : 443))\n    )\n  )\n\n  //console.debug('is_crossDomain('+url+') -> ' + result)\n  return result\n}\n\n// MIT License from http://phpjs.org/functions/base64_encode:358\nfunction b64_enc (data) {\n    // Encodes string using MIME base64 algorithm\n    var b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n    var o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, enc=\"\", tmp_arr = [];\n\n    if (!data) {\n        return data;\n    }\n\n    // assume utf8 data\n    // data = this.utf8_encode(data+'');\n\n    do { // pack three octets into four hexets\n        o1 = data.charCodeAt(i++);\n        o2 = data.charCodeAt(i++);\n        o3 = data.charCodeAt(i++);\n\n        bits = o1<<16 | o2<<8 | o3;\n\n        h1 = bits>>18 & 0x3f;\n        h2 = bits>>12 & 0x3f;\n        h3 = bits>>6 & 0x3f;\n        h4 = bits & 0x3f;\n\n        // use hexets to index into b64, and append result to encoded string\n        tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);\n    } while (i < data.length);\n\n    enc = tmp_arr.join('');\n\n    switch (data.length % 3) {\n        case 1:\n            enc = enc.slice(0, -2) + '==';\n        break;\n        case 2:\n            enc = enc.slice(0, -1) + '=';\n        break;\n    }\n\n    return enc;\n}\n\n//@ sourceURL=/node_modules/coax/node_modules/hoax/node_modules/browser-request/dist/ender/request.js"
));

require.define("/node_modules/coax/node_modules/hoax/node_modules/browser-request/dist/ender/xmlhttprequest.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\n\n!function(window) {\n  if(typeof exports === 'undefined')\n    throw new Error('Cannot find global \"exports\" object. Is this really CommonJS?')\n  if(typeof module === 'undefined')\n    throw new Error('Cannot find global \"module\" object. Is this really CommonJS?')\n  if(!module.exports)\n    throw new Error('Cannot find global \"module.exports\" object. Is this really CommonJS?')\n\n  // Define globals to simulate a browser environment.\n  window = window || {}\n\n  var document = window.document || {}\n  if(!window.document)\n    window.document = document\n\n  var navigator = window.navigator || {}\n  if(!window.navigator)\n    window.navigator = navigator\n\n  if(!navigator.userAgent)\n    navigator.userAgent = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_2) AppleWebKit/534.51.22 (KHTML, like Gecko) Version/5.1.1 Safari/534.51.22';\n\n  // Remember the old values in window. If the inner code changes anything, export that as a module and restore the old window value.\n  var win = {}\n    , key\n\n  for (key in window)\n    if(window.hasOwnProperty(key))\n      win[key] = window[key]\n\n  run_code()\n\n  for (key in window)\n    if(window.hasOwnProperty(key))\n      if(window[key] !== win[key]) {\n        exports[key] = window[key]\n        window[key] = win[key]\n      }\n\n  function run_code() {\n    // Begin browser file: XMLHttpRequest.js\n/**\n* XMLHttpRequest.js Copyright (C) 2011 Sergey Ilinsky (http://www.ilinsky.com)\n*\n* This work is free software; you can redistribute it and/or modify\n* it under the terms of the GNU Lesser General Public License as published by\n* the Free Software Foundation; either version 2.1 of the License, or\n* (at your option) any later version.\n*\n* This work is distributed in the hope that it will be useful,\n* but without any warranty; without even the implied warranty of\n* merchantability or fitness for a particular purpose. See the\n* GNU Lesser General Public License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public License\n* along with this library; if not, write to the Free Software Foundation, Inc.,\n* 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n*/\n\n(function () {\n\n\t// Save reference to earlier defined object implementation (if any)\n\tvar oXMLHttpRequest = window.XMLHttpRequest;\n\n\t// Define on browser type\n\tvar bGecko  = !!window.controllers;\n\tvar bIE     = !!window.document.namespaces;\n\tvar bIE7    = bIE && window.navigator.userAgent.match(/MSIE 7.0/);\n\n\t// Enables \"XMLHttpRequest()\" call next to \"new XMLHttpRequest()\"\n\tfunction fXMLHttpRequest() {\n\t\tthis._object  = oXMLHttpRequest && !bIE7 ? new oXMLHttpRequest : new window.ActiveXObject(\"Microsoft.XMLHTTP\");\n\t\tthis._listeners = [];\n\t}\n\n\t// Constructor\n\tfunction cXMLHttpRequest() {\n\t\treturn new fXMLHttpRequest;\n\t}\n\tcXMLHttpRequest.prototype = fXMLHttpRequest.prototype;\n\n\t// BUGFIX: Firefox with Firebug installed would break pages if not executed\n\tif (bGecko && oXMLHttpRequest.wrapped) {\n\t\tcXMLHttpRequest.wrapped = oXMLHttpRequest.wrapped;\n\t}\n\n\t// Constants\n\tcXMLHttpRequest.UNSENT            = 0;\n\tcXMLHttpRequest.OPENED            = 1;\n\tcXMLHttpRequest.HEADERS_RECEIVED  = 2;\n\tcXMLHttpRequest.LOADING           = 3;\n\tcXMLHttpRequest.DONE              = 4;\n\n\t// Interface level constants\n\tcXMLHttpRequest.prototype.UNSENT            = cXMLHttpRequest.UNSENT;\n\tcXMLHttpRequest.prototype.OPENED            = cXMLHttpRequest.OPENED;\n\tcXMLHttpRequest.prototype.HEADERS_RECEIVED  = cXMLHttpRequest.HEADERS_RECEIVED;\n\tcXMLHttpRequest.prototype.LOADING           = cXMLHttpRequest.LOADING;\n\tcXMLHttpRequest.prototype.DONE              = cXMLHttpRequest.DONE;\n\n\t// Public Properties\n\tcXMLHttpRequest.prototype.readyState    = cXMLHttpRequest.UNSENT;\n\tcXMLHttpRequest.prototype.responseText  = '';\n\tcXMLHttpRequest.prototype.responseXML   = null;\n\tcXMLHttpRequest.prototype.status        = 0;\n\tcXMLHttpRequest.prototype.statusText    = '';\n\n\t// Priority proposal\n\tcXMLHttpRequest.prototype.priority    = \"NORMAL\";\n\n\t// Instance-level Events Handlers\n\tcXMLHttpRequest.prototype.onreadystatechange  = null;\n\n\t// Class-level Events Handlers\n\tcXMLHttpRequest.onreadystatechange  = null;\n\tcXMLHttpRequest.onopen              = null;\n\tcXMLHttpRequest.onsend              = null;\n\tcXMLHttpRequest.onabort             = null;\n\n\t// Public Methods\n\tcXMLHttpRequest.prototype.open  = function(sMethod, sUrl, bAsync, sUser, sPassword) {\n\t\t// http://www.w3.org/TR/XMLHttpRequest/#the-open-method\n\t\tvar sLowerCaseMethod = sMethod.toLowerCase();\n\t\tif (sLowerCaseMethod == \"connect\" || sLowerCaseMethod == \"trace\" || sLowerCaseMethod == \"track\") {\n\t\t\t// Using a generic error and an int - not too sure all browsers support correctly\n\t\t\t// http://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html#securityerror, so, this is safer\n\t\t\t// XXX should do better than that, but this is OT to XHR.\n\t\t\tthrow new Error(18);\n\t\t}\n\n\t\t// Delete headers, required when object is reused\n\t\tdelete this._headers;\n\n\t\t// When bAsync parameter value is omitted, use true as default\n\t\tif (arguments.length < 3) {\n\t\t\tbAsync  = true;\n\t\t}\n\n\t\t// Save async parameter for fixing Gecko bug with missing readystatechange in synchronous requests\n\t\tthis._async   = bAsync;\n\n\t\t// Set the onreadystatechange handler\n\t\tvar oRequest  = this;\n\t\tvar nState    = this.readyState;\n\t\tvar fOnUnload = null;\n\n\t\t// BUGFIX: IE - memory leak on page unload (inter-page leak)\n\t\tif (bIE && bAsync) {\n\t\t\tfOnUnload = function() {\n\t\t\t\tif (nState != cXMLHttpRequest.DONE) {\n\t\t\t\t\tfCleanTransport(oRequest);\n\t\t\t\t\t// Safe to abort here since onreadystatechange handler removed\n\t\t\t\t\toRequest.abort();\n\t\t\t\t}\n\t\t\t};\n\t\t\twindow.attachEvent(\"onunload\", fOnUnload);\n\t\t}\n\n\t\t// Add method sniffer\n\t\tif (cXMLHttpRequest.onopen) {\n\t\t\tcXMLHttpRequest.onopen.apply(this, arguments);\n\t\t}\n\n\t\tif (arguments.length > 4) {\n\t\t\tthis._object.open(sMethod, sUrl, bAsync, sUser, sPassword);\n\t\t} else if (arguments.length > 3) {\n\t\t\tthis._object.open(sMethod, sUrl, bAsync, sUser);\n\t\t} else {\n\t\t\tthis._object.open(sMethod, sUrl, bAsync);\n\t\t}\n\n\t\tthis.readyState = cXMLHttpRequest.OPENED;\n\t\tfReadyStateChange(this);\n\n\t\tthis._object.onreadystatechange = function() {\n\t\t\tif (bGecko && !bAsync) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Synchronize state\n\t\t\toRequest.readyState   = oRequest._object.readyState;\n\t\t\tfSynchronizeValues(oRequest);\n\n\t\t\t// BUGFIX: Firefox fires unnecessary DONE when aborting\n\t\t\tif (oRequest._aborted) {\n\t\t\t\t// Reset readyState to UNSENT\n\t\t\t\toRequest.readyState = cXMLHttpRequest.UNSENT;\n\n\t\t\t\t// Return now\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (oRequest.readyState == cXMLHttpRequest.DONE) {\n\t\t\t\t// Free up queue\n\t\t\t\tdelete oRequest._data;\n\n\t\t\t\t// Uncomment these lines for bAsync\n\t\t\t\t/**\n\t\t\t\t * if (bAsync) {\n\t\t\t\t * \tfQueue_remove(oRequest);\n\t\t\t\t * }\n\t\t\t\t */\n\n\t\t\t\tfCleanTransport(oRequest);\n\n\t\t\t\t// Uncomment this block if you need a fix for IE cache\n\t\t\t\t/**\n\t\t\t\t * // BUGFIX: IE - cache issue\n\t\t\t\t * if (!oRequest._object.getResponseHeader(\"Date\")) {\n\t\t\t\t * \t// Save object to cache\n\t\t\t\t * \toRequest._cached  = oRequest._object;\n\t\t\t\t *\n\t\t\t\t * \t// Instantiate a new transport object\n\t\t\t\t * \tcXMLHttpRequest.call(oRequest);\n\t\t\t\t *\n\t\t\t\t * \t// Re-send request\n\t\t\t\t * \tif (sUser) {\n\t\t\t\t * \t\tif (sPassword) {\n\t\t\t\t * \t\t\toRequest._object.open(sMethod, sUrl, bAsync, sUser, sPassword);\n\t\t\t\t * \t\t} else {\n\t\t\t\t * \t\t\toRequest._object.open(sMethod, sUrl, bAsync);\n\t\t\t\t * \t\t}\n\t\t\t\t *\n\t\t\t\t * \t\toRequest._object.setRequestHeader(\"If-Modified-Since\", oRequest._cached.getResponseHeader(\"Last-Modified\") || new window.Date(0));\n\t\t\t\t * \t\t// Copy headers set\n\t\t\t\t * \t\tif (oRequest._headers) {\n\t\t\t\t * \t\t\tfor (var sHeader in oRequest._headers) {\n\t\t\t\t * \t\t\t\t// Some frameworks prototype objects with functions\n\t\t\t\t * \t\t\t\tif (typeof oRequest._headers[sHeader] == \"string\") {\n\t\t\t\t * \t\t\t\t\toRequest._object.setRequestHeader(sHeader, oRequest._headers[sHeader]);\n\t\t\t\t * \t\t\t\t}\n\t\t\t\t * \t\t\t}\n\t\t\t\t * \t\t}\n\t\t\t\t * \t\toRequest._object.onreadystatechange = function() {\n\t\t\t\t * \t\t\t// Synchronize state\n\t\t\t\t * \t\t\toRequest.readyState   = oRequest._object.readyState;\n\t\t\t\t *\n\t\t\t\t * \t\t\tif (oRequest._aborted) {\n\t\t\t\t * \t\t\t\t//\n\t\t\t\t * \t\t\t\toRequest.readyState = cXMLHttpRequest.UNSENT;\n\t\t\t\t *\n\t\t\t\t * \t\t\t\t// Return\n\t\t\t\t * \t\t\t\treturn;\n\t\t\t\t * \t\t\t}\n\t\t\t\t *\n\t\t\t\t * \t\t\tif (oRequest.readyState == cXMLHttpRequest.DONE) {\n\t\t\t\t * \t\t\t\t// Clean Object\n\t\t\t\t * \t\t\t\tfCleanTransport(oRequest);\n\t\t\t\t *\n\t\t\t\t * \t\t\t\t// get cached request\n\t\t\t\t * \t\t\t\tif (oRequest.status == 304) {\n\t\t\t\t * \t\t\t\t\toRequest._object  = oRequest._cached;\n\t\t\t\t * \t\t\t\t}\n\t\t\t\t *\n\t\t\t\t * \t\t\t\t//\n\t\t\t\t * \t\t\t\tdelete oRequest._cached;\n\t\t\t\t *\n\t\t\t\t * \t\t\t\t//\n\t\t\t\t * \t\t\t\tfSynchronizeValues(oRequest);\n\t\t\t\t *\n\t\t\t\t * \t\t\t\t//\n\t\t\t\t * \t\t\t\tfReadyStateChange(oRequest);\n\t\t\t\t *\n\t\t\t\t * \t\t\t\t// BUGFIX: IE - memory leak in interrupted\n\t\t\t\t * \t\t\t\tif (bIE && bAsync) {\n\t\t\t\t * \t\t\t\t\twindow.detachEvent(\"onunload\", fOnUnload);\n\t\t\t\t * \t\t\t\t}\n\t\t\t\t *\n\t\t\t\t * \t\t\t}\n\t\t\t\t * \t\t};\n\t\t\t\t * \t\toRequest._object.send(null);\n\t\t\t\t *\n\t\t\t\t * \t\t// Return now - wait until re-sent request is finished\n\t\t\t\t * \t\treturn;\n\t\t\t\t * \t};\n\t\t\t\t */\n\n\t\t\t\t// BUGFIX: IE - memory leak in interrupted\n\t\t\t\tif (bIE && bAsync) {\n\t\t\t\t\twindow.detachEvent(\"onunload\", fOnUnload);\n\t\t\t\t}\n\n\t\t\t\t// BUGFIX: Some browsers (Internet Explorer, Gecko) fire OPEN readystate twice\n\t\t\t\tif (nState != oRequest.readyState) {\n\t\t\t\t\tfReadyStateChange(oRequest);\n\t\t\t\t}\n\n\t\t\t\tnState  = oRequest.readyState;\n\t\t\t}\n\t\t};\n\t};\n\n\tcXMLHttpRequest.prototype.send = function(vData) {\n\t\t// Add method sniffer\n\t\tif (cXMLHttpRequest.onsend) {\n\t\t\tcXMLHttpRequest.onsend.apply(this, arguments);\n\t\t}\n\n\t\tif (!arguments.length) {\n\t\t\tvData = null;\n\t\t}\n\n\t\t// BUGFIX: Safari - fails sending documents created/modified dynamically, so an explicit serialization required\n\t\t// BUGFIX: IE - rewrites any custom mime-type to \"text/xml\" in case an XMLNode is sent\n\t\t// BUGFIX: Gecko - fails sending Element (this is up to the implementation either to standard)\n\t\tif (vData && vData.nodeType) {\n\t\t\tvData = window.XMLSerializer ? new window.XMLSerializer().serializeToString(vData) : vData.xml;\n\t\t\tif (!this._headers[\"Content-Type\"]) {\n\t\t\t\tthis._object.setRequestHeader(\"Content-Type\", \"application/xml\");\n\t\t\t}\n\t\t}\n\n\t\tthis._data = vData;\n\n\t\t/**\n\t\t * // Add to queue\n\t\t * if (this._async) {\n\t\t * \tfQueue_add(this);\n\t\t * } else { */\n\t\tfXMLHttpRequest_send(this);\n\t\t /**\n\t\t * }\n\t\t */\n\t};\n\n\tcXMLHttpRequest.prototype.abort = function() {\n\t\t// Add method sniffer\n\t\tif (cXMLHttpRequest.onabort) {\n\t\t\tcXMLHttpRequest.onabort.apply(this, arguments);\n\t\t}\n\n\t\t// BUGFIX: Gecko - unnecessary DONE when aborting\n\t\tif (this.readyState > cXMLHttpRequest.UNSENT) {\n\t\t\tthis._aborted = true;\n\t\t}\n\n\t\tthis._object.abort();\n\n\t\t// BUGFIX: IE - memory leak\n\t\tfCleanTransport(this);\n\n\t\tthis.readyState = cXMLHttpRequest.UNSENT;\n\n\t\tdelete this._data;\n\n\t\t/* if (this._async) {\n\t \t* \tfQueue_remove(this);\n\t \t* }\n\t \t*/\n\t};\n\n\tcXMLHttpRequest.prototype.getAllResponseHeaders = function() {\n\t\treturn this._object.getAllResponseHeaders();\n\t};\n\n\tcXMLHttpRequest.prototype.getResponseHeader = function(sName) {\n\t\treturn this._object.getResponseHeader(sName);\n\t};\n\n\tcXMLHttpRequest.prototype.setRequestHeader  = function(sName, sValue) {\n\t\t// BUGFIX: IE - cache issue\n\t\tif (!this._headers) {\n\t\t\tthis._headers = {};\n\t\t}\n\n\t\tthis._headers[sName]  = sValue;\n\n\t\treturn this._object.setRequestHeader(sName, sValue);\n\t};\n\n\t// EventTarget interface implementation\n\tcXMLHttpRequest.prototype.addEventListener  = function(sName, fHandler, bUseCapture) {\n\t\tfor (var nIndex = 0, oListener; oListener = this._listeners[nIndex]; nIndex++) {\n\t\t\tif (oListener[0] == sName && oListener[1] == fHandler && oListener[2] == bUseCapture) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Add listener\n\t\tthis._listeners.push([sName, fHandler, bUseCapture]);\n\t};\n\n\tcXMLHttpRequest.prototype.removeEventListener = function(sName, fHandler, bUseCapture) {\n\t\tfor (var nIndex = 0, oListener; oListener = this._listeners[nIndex]; nIndex++) {\n\t\t\tif (oListener[0] == sName && oListener[1] == fHandler && oListener[2] == bUseCapture) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Remove listener\n\t\tif (oListener) {\n\t\t\tthis._listeners.splice(nIndex, 1);\n\t\t}\n\t};\n\n\tcXMLHttpRequest.prototype.dispatchEvent = function(oEvent) {\n\t\tvar oEventPseudo  = {\n\t\t\t'type':             oEvent.type,\n\t\t\t'target':           this,\n\t\t\t'currentTarget':    this,\n\t\t\t'eventPhase':       2,\n\t\t\t'bubbles':          oEvent.bubbles,\n\t\t\t'cancelable':       oEvent.cancelable,\n\t\t\t'timeStamp':        oEvent.timeStamp,\n\t\t\t'stopPropagation':  function() {},  // There is no flow\n\t\t\t'preventDefault':   function() {},  // There is no default action\n\t\t\t'initEvent':        function() {}   // Original event object should be initialized\n\t\t};\n\n\t\t// Execute onreadystatechange\n\t\tif (oEventPseudo.type == \"readystatechange\" && this.onreadystatechange) {\n\t\t\t(this.onreadystatechange.handleEvent || this.onreadystatechange).apply(this, [oEventPseudo]);\n\t\t}\n\n\n\t\t// Execute listeners\n\t\tfor (var nIndex = 0, oListener; oListener = this._listeners[nIndex]; nIndex++) {\n\t\t\tif (oListener[0] == oEventPseudo.type && !oListener[2]) {\n\t\t\t\t(oListener[1].handleEvent || oListener[1]).apply(this, [oEventPseudo]);\n\t\t\t}\n\t\t}\n\n\t};\n\n\t//\n\tcXMLHttpRequest.prototype.toString  = function() {\n\t\treturn '[' + \"object\" + ' ' + \"XMLHttpRequest\" + ']';\n\t};\n\n\tcXMLHttpRequest.toString  = function() {\n\t\treturn '[' + \"XMLHttpRequest\" + ']';\n\t};\n\n\t/**\n\t * // Queue manager\n\t * var oQueuePending = {\"CRITICAL\":[],\"HIGH\":[],\"NORMAL\":[],\"LOW\":[],\"LOWEST\":[]},\n\t * aQueueRunning = [];\n\t * function fQueue_add(oRequest) {\n\t * \toQueuePending[oRequest.priority in oQueuePending ? oRequest.priority : \"NORMAL\"].push(oRequest);\n\t * \t//\n\t * \tsetTimeout(fQueue_process);\n\t * };\n\t *\n\t * function fQueue_remove(oRequest) {\n\t * \tfor (var nIndex = 0, bFound = false; nIndex < aQueueRunning.length; nIndex++)\n\t * \tif (bFound) {\n\t * \t\taQueueRunning[nIndex - 1] = aQueueRunning[nIndex];\n\t * \t} else {\n\t * \t\tif (aQueueRunning[nIndex] == oRequest) {\n\t * \t\t\tbFound  = true;\n\t * \t\t}\n\t * }\n\t *\n\t * \tif (bFound) {\n\t * \t\taQueueRunning.length--;\n\t * \t}\n\t *\n\t *\n\t * \t//\n\t * \tsetTimeout(fQueue_process);\n\t * };\n\t *\n\t * function fQueue_process() {\n\t * if (aQueueRunning.length < 6) {\n\t * for (var sPriority in oQueuePending) {\n\t * if (oQueuePending[sPriority].length) {\n\t * var oRequest  = oQueuePending[sPriority][0];\n\t * oQueuePending[sPriority]  = oQueuePending[sPriority].slice(1);\n\t * //\n\t * aQueueRunning.push(oRequest);\n\t * // Send request\n\t * fXMLHttpRequest_send(oRequest);\n\t * break;\n\t * }\n\t * }\n\t * }\n\t * };\n\t */\n\n\t// Helper function\n\tfunction fXMLHttpRequest_send(oRequest) {\n\t\toRequest._object.send(oRequest._data);\n\n\t\t// BUGFIX: Gecko - missing readystatechange calls in synchronous requests\n\t\tif (bGecko && !oRequest._async) {\n\t\t\toRequest.readyState = cXMLHttpRequest.OPENED;\n\n\t\t\t// Synchronize state\n\t\t\tfSynchronizeValues(oRequest);\n\n\t\t\t// Simulate missing states\n\t\t\twhile (oRequest.readyState < cXMLHttpRequest.DONE) {\n\t\t\t\toRequest.readyState++;\n\t\t\t\tfReadyStateChange(oRequest);\n\t\t\t\t// Check if we are aborted\n\t\t\t\tif (oRequest._aborted) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction fReadyStateChange(oRequest) {\n\t\t// Sniffing code\n\t\tif (cXMLHttpRequest.onreadystatechange){\n\t\t\tcXMLHttpRequest.onreadystatechange.apply(oRequest);\n\t\t}\n\n\n\t\t// Fake event\n\t\toRequest.dispatchEvent({\n\t\t\t'type':       \"readystatechange\",\n\t\t\t'bubbles':    false,\n\t\t\t'cancelable': false,\n\t\t\t'timeStamp':  new Date + 0\n\t\t});\n\t}\n\n\tfunction fGetDocument(oRequest) {\n\t\tvar oDocument = oRequest.responseXML;\n\t\tvar sResponse = oRequest.responseText;\n\t\t// Try parsing responseText\n\t\tif (bIE && sResponse && oDocument && !oDocument.documentElement && oRequest.getResponseHeader(\"Content-Type\").match(/[^\\/]+\\/[^\\+]+\\+xml/)) {\n\t\t\toDocument = new window.ActiveXObject(\"Microsoft.XMLDOM\");\n\t\t\toDocument.async       = false;\n\t\t\toDocument.validateOnParse = false;\n\t\t\toDocument.loadXML(sResponse);\n\t\t}\n\n\t\t// Check if there is no error in document\n\t\tif (oDocument){\n\t\t\tif ((bIE && oDocument.parseError !== 0) || !oDocument.documentElement || (oDocument.documentElement && oDocument.documentElement.tagName == \"parsererror\")) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn oDocument;\n\t}\n\n\tfunction fSynchronizeValues(oRequest) {\n\t\ttry { oRequest.responseText = oRequest._object.responseText;  } catch (e) {}\n\t\ttry { oRequest.responseXML  = fGetDocument(oRequest._object); } catch (e) {}\n\t\ttry { oRequest.status       = oRequest._object.status;        } catch (e) {}\n\t\ttry { oRequest.statusText   = oRequest._object.statusText;    } catch (e) {}\n\t}\n\n\tfunction fCleanTransport(oRequest) {\n\t\t// BUGFIX: IE - memory leak (on-page leak)\n\t\toRequest._object.onreadystatechange = new window.Function;\n\t}\n\n\t// Internet Explorer 5.0 (missing apply)\n\tif (!window.Function.prototype.apply) {\n\t\twindow.Function.prototype.apply = function(oRequest, oArguments) {\n\t\t\tif (!oArguments) {\n\t\t\t\toArguments  = [];\n\t\t\t}\n\t\t\toRequest.__func = this;\n\t\t\toRequest.__func(oArguments[0], oArguments[1], oArguments[2], oArguments[3], oArguments[4]);\n\t\t\tdelete oRequest.__func;\n\t\t};\n\t}\n\n\t// Register new object with window\n\twindow.XMLHttpRequest = cXMLHttpRequest;\n\n})();\n\n    // End browser file: XMLHttpRequest.js\n  }\n}(typeof window !== 'undefined' ? window : {});\n\n//@ sourceURL=/node_modules/coax/node_modules/hoax/node_modules/browser-request/dist/ender/xmlhttprequest.js"
));

require.define("/node_modules/async/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./index\"}\n//@ sourceURL=/node_modules/async/package.json"
));

require.define("/node_modules/async/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// This file is just added for convenience so this repository can be\n// directly checked out into a project's deps folder\nmodule.exports = require('./lib/async');\n\n//@ sourceURL=/node_modules/async/index.js"
));

require.define("/node_modules/async/lib/async.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*global setTimeout: false, console: false */\n(function () {\n\n    var async = {};\n\n    // global on the server, window in the browser\n    var root = this,\n        previous_async = root.async;\n\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = async;\n    }\n    else {\n        root.async = async;\n    }\n\n    async.noConflict = function () {\n        root.async = previous_async;\n        return async;\n    };\n\n    //// cross-browser compatiblity functions ////\n\n    var _forEach = function (arr, iterator) {\n        if (arr.forEach) {\n            return arr.forEach(iterator);\n        }\n        for (var i = 0; i < arr.length; i += 1) {\n            iterator(arr[i], i, arr);\n        }\n    };\n\n    var _map = function (arr, iterator) {\n        if (arr.map) {\n            return arr.map(iterator);\n        }\n        var results = [];\n        _forEach(arr, function (x, i, a) {\n            results.push(iterator(x, i, a));\n        });\n        return results;\n    };\n\n    var _reduce = function (arr, iterator, memo) {\n        if (arr.reduce) {\n            return arr.reduce(iterator, memo);\n        }\n        _forEach(arr, function (x, i, a) {\n            memo = iterator(memo, x, i, a);\n        });\n        return memo;\n    };\n\n    var _keys = function (obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        }\n        var keys = [];\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                keys.push(k);\n            }\n        }\n        return keys;\n    };\n\n    //// exported async module functions ////\n\n    //// nextTick implementation with browser-compatible fallback ////\n    if (typeof process === 'undefined' || !(process.nextTick)) {\n        async.nextTick = function (fn) {\n            setTimeout(fn, 0);\n        };\n    }\n    else {\n        async.nextTick = process.nextTick;\n    }\n\n    async.forEach = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        _forEach(arr, function (x) {\n            iterator(x, function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed === arr.length) {\n                        callback(null);\n                    }\n                }\n            });\n        });\n    };\n\n    async.forEachSeries = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        var iterate = function () {\n            iterator(arr[completed], function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed === arr.length) {\n                        callback(null);\n                    }\n                    else {\n                        iterate();\n                    }\n                }\n            });\n        };\n        iterate();\n    };\n\n    async.forEachLimit = function (arr, limit, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length || limit <= 0) {\n            return callback();\n        }\n        var completed = 0;\n        var started = 0;\n        var running = 0;\n\n        (function replenish () {\n            if (completed === arr.length) {\n                return callback();\n            }\n\n            while (running < limit && started < arr.length) {\n                started += 1;\n                running += 1;\n                iterator(arr[started - 1], function (err) {\n                    if (err) {\n                        callback(err);\n                        callback = function () {};\n                    }\n                    else {\n                        completed += 1;\n                        running -= 1;\n                        if (completed === arr.length) {\n                            callback();\n                        }\n                        else {\n                            replenish();\n                        }\n                    }\n                });\n            }\n        })();\n    };\n\n\n    var doParallel = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.forEach].concat(args));\n        };\n    };\n    var doSeries = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.forEachSeries].concat(args));\n        };\n    };\n\n\n    var _asyncMap = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (err, v) {\n                results[x.index] = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, results);\n        });\n    };\n    async.map = doParallel(_asyncMap);\n    async.mapSeries = doSeries(_asyncMap);\n\n\n    // reduce only has a series version, as doing reduce in parallel won't\n    // work in many situations.\n    async.reduce = function (arr, memo, iterator, callback) {\n        async.forEachSeries(arr, function (x, callback) {\n            iterator(memo, x, function (err, v) {\n                memo = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, memo);\n        });\n    };\n    // inject alias\n    async.inject = async.reduce;\n    // foldl alias\n    async.foldl = async.reduce;\n\n    async.reduceRight = function (arr, memo, iterator, callback) {\n        var reversed = _map(arr, function (x) {\n            return x;\n        }).reverse();\n        async.reduce(reversed, memo, iterator, callback);\n    };\n    // foldr alias\n    async.foldr = async.reduceRight;\n\n    var _filter = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.filter = doParallel(_filter);\n    async.filterSeries = doSeries(_filter);\n    // select alias\n    async.select = async.filter;\n    async.selectSeries = async.filterSeries;\n\n    var _reject = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (!v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.reject = doParallel(_reject);\n    async.rejectSeries = doSeries(_reject);\n\n    var _detect = function (eachfn, arr, iterator, main_callback) {\n        eachfn(arr, function (x, callback) {\n            iterator(x, function (result) {\n                if (result) {\n                    main_callback(x);\n                    main_callback = function () {};\n                }\n                else {\n                    callback();\n                }\n            });\n        }, function (err) {\n            main_callback();\n        });\n    };\n    async.detect = doParallel(_detect);\n    async.detectSeries = doSeries(_detect);\n\n    async.some = function (arr, iterator, main_callback) {\n        async.forEach(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (v) {\n                    main_callback(true);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(false);\n        });\n    };\n    // any alias\n    async.any = async.some;\n\n    async.every = function (arr, iterator, main_callback) {\n        async.forEach(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (!v) {\n                    main_callback(false);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(true);\n        });\n    };\n    // all alias\n    async.all = async.every;\n\n    async.sortBy = function (arr, iterator, callback) {\n        async.map(arr, function (x, callback) {\n            iterator(x, function (err, criteria) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    callback(null, {value: x, criteria: criteria});\n                }\n            });\n        }, function (err, results) {\n            if (err) {\n                return callback(err);\n            }\n            else {\n                var fn = function (left, right) {\n                    var a = left.criteria, b = right.criteria;\n                    return a < b ? -1 : a > b ? 1 : 0;\n                };\n                callback(null, _map(results.sort(fn), function (x) {\n                    return x.value;\n                }));\n            }\n        });\n    };\n\n    async.auto = function (tasks, callback) {\n        callback = callback || function () {};\n        var keys = _keys(tasks);\n        if (!keys.length) {\n            return callback(null);\n        }\n\n        var results = {};\n\n        var listeners = [];\n        var addListener = function (fn) {\n            listeners.unshift(fn);\n        };\n        var removeListener = function (fn) {\n            for (var i = 0; i < listeners.length; i += 1) {\n                if (listeners[i] === fn) {\n                    listeners.splice(i, 1);\n                    return;\n                }\n            }\n        };\n        var taskComplete = function () {\n            _forEach(listeners.slice(0), function (fn) {\n                fn();\n            });\n        };\n\n        addListener(function () {\n            if (_keys(results).length === keys.length) {\n                callback(null, results);\n                callback = function () {};\n            }\n        });\n\n        _forEach(keys, function (k) {\n            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];\n            var taskCallback = function (err) {\n                if (err) {\n                    callback(err);\n                    // stop subsequent errors hitting callback multiple times\n                    callback = function () {};\n                }\n                else {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    taskComplete();\n                }\n            };\n            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\n            var ready = function () {\n                return _reduce(requires, function (a, x) {\n                    return (a && results.hasOwnProperty(x));\n                }, true) && !results.hasOwnProperty(k);\n            };\n            if (ready()) {\n                task[task.length - 1](taskCallback, results);\n            }\n            else {\n                var listener = function () {\n                    if (ready()) {\n                        removeListener(listener);\n                        task[task.length - 1](taskCallback, results);\n                    }\n                };\n                addListener(listener);\n            }\n        });\n    };\n\n    async.waterfall = function (tasks, callback) {\n        callback = callback || function () {};\n        if (!tasks.length) {\n            return callback();\n        }\n        var wrapIterator = function (iterator) {\n            return function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    var next = iterator.next();\n                    if (next) {\n                        args.push(wrapIterator(next));\n                    }\n                    else {\n                        args.push(callback);\n                    }\n                    async.nextTick(function () {\n                        iterator.apply(null, args);\n                    });\n                }\n            };\n        };\n        wrapIterator(async.iterator(tasks))();\n    };\n\n    async.parallel = function (tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor === Array) {\n            async.map(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            async.forEach(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.series = function (tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor === Array) {\n            async.mapSeries(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            async.forEachSeries(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.iterator = function (tasks) {\n        var makeCallback = function (index) {\n            var fn = function () {\n                if (tasks.length) {\n                    tasks[index].apply(null, arguments);\n                }\n                return fn.next();\n            };\n            fn.next = function () {\n                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n            };\n            return fn;\n        };\n        return makeCallback(0);\n    };\n\n    async.apply = function (fn) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        return function () {\n            return fn.apply(\n                null, args.concat(Array.prototype.slice.call(arguments))\n            );\n        };\n    };\n\n    var _concat = function (eachfn, arr, fn, callback) {\n        var r = [];\n        eachfn(arr, function (x, cb) {\n            fn(x, function (err, y) {\n                r = r.concat(y || []);\n                cb(err);\n            });\n        }, function (err) {\n            callback(err, r);\n        });\n    };\n    async.concat = doParallel(_concat);\n    async.concatSeries = doSeries(_concat);\n\n    async.whilst = function (test, iterator, callback) {\n        if (test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.whilst(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.until = function (test, iterator, callback) {\n        if (!test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.until(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.queue = function (worker, concurrency) {\n        var workers = 0;\n        var q = {\n            tasks: [],\n            concurrency: concurrency,\n            saturated: null,\n            empty: null,\n            drain: null,\n            push: function (data, callback) {\n                if(data.constructor !== Array) {\n                    data = [data];\n                }\n                _forEach(data, function(task) {\n                    q.tasks.push({\n                        data: task,\n                        callback: typeof callback === 'function' ? callback : null\n                    });\n                    if (q.saturated && q.tasks.length == concurrency) {\n                        q.saturated();\n                    }\n                    async.nextTick(q.process);\n                });\n            },\n            process: function () {\n                if (workers < q.concurrency && q.tasks.length) {\n                    var task = q.tasks.shift();\n                    if(q.empty && q.tasks.length == 0) q.empty();\n                    workers += 1;\n                    worker(task.data, function () {\n                        workers -= 1;\n                        if (task.callback) {\n                            task.callback.apply(task, arguments);\n                        }\n                        if(q.drain && q.tasks.length + workers == 0) q.drain();\n                        q.process();\n                    });\n                }\n            },\n            length: function () {\n                return q.tasks.length;\n            },\n            running: function () {\n                return workers;\n            }\n        };\n        return q;\n    };\n\n    var _console_fn = function (name) {\n        return function (fn) {\n            var args = Array.prototype.slice.call(arguments, 1);\n            fn.apply(null, args.concat([function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (typeof console !== 'undefined') {\n                    if (err) {\n                        if (console.error) {\n                            console.error(err);\n                        }\n                    }\n                    else if (console[name]) {\n                        _forEach(args, function (x) {\n                            console[name](x);\n                        });\n                    }\n                }\n            }]));\n        };\n    };\n    async.log = _console_fn('log');\n    async.dir = _console_fn('dir');\n    /*async.info = _console_fn('info');\n    async.warn = _console_fn('warn');\n    async.error = _console_fn('error');*/\n\n    async.memoize = function (fn, hasher) {\n        var memo = {};\n        var queues = {};\n        hasher = hasher || function (x) {\n            return x;\n        };\n        var memoized = function () {\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            var key = hasher.apply(null, args);\n            if (key in memo) {\n                callback.apply(null, memo[key]);\n            }\n            else if (key in queues) {\n                queues[key].push(callback);\n            }\n            else {\n                queues[key] = [callback];\n                fn.apply(null, args.concat([function () {\n                    memo[key] = arguments;\n                    var q = queues[key];\n                    delete queues[key];\n                    for (var i = 0, l = q.length; i < l; i++) {\n                      q[i].apply(null, arguments);\n                    }\n                }]));\n            }\n        };\n        memoized.unmemoized = fn;\n        return memoized;\n    };\n\n    async.unmemoize = function (fn) {\n      return function () {\n        return (fn.unmemoized || fn).apply(null, arguments);\n      };\n    };\n\n}());\n\n//@ sourceURL=/node_modules/async/lib/async.js"
));

require.define("/node_modules/fastclick/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"lib/fastclick.js\"}\n//@ sourceURL=/node_modules/fastclick/package.json"
));

require.define("/node_modules/fastclick/lib/fastclick.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/**\n * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.\n *\n * @version 0.4.5\n * @codingstandard ftlabs-jsv2\n * @copyright The Financial Times Limited [All Rights Reserved]\n * @license MIT License (see LICENSE.txt)\n */\n\n/*jslint browser:true, node:true*/\n/*global define*/\n\n\n/**\n * Instantiate fast-clicking listeners on the specificed layer.\n *\n * @constructor\n * @param {Element} layer The layer to listen on\n */\nfunction FastClick(layer) {\n\t'use strict';\n\tvar oldOnClick, self = this;\n\n\n\t/**\n\t * Whether a click is currently being tracked.\n\t *\n\t * @type boolean\n\t */\n\tthis.trackingClick = false;\n\n\n\t/**\n\t * Timestamp for when when click tracking started.\n\t *\n\t * @type number\n\t */\n\tthis.trackingClickStart = 0;\n\n\n\t/**\n\t * The element being tracked for a click.\n\t *\n\t * @type EventTarget\n\t */\n\tthis.targetElement = null;\n\n\n\t/**\n\t * X-coordinate of touch start event.\n\t *\n\t * @type number\n\t */\n\tthis.touchStartX = 0;\n\n\n\t/**\n\t * Y-coordinate of touch start event.\n\t *\n\t * @type number\n\t */\n\tthis.touchStartY = 0;\n\n\n\t/**\n\t * The FastClick layer.\n\t *\n\t * @type Element\n\t */\n\tthis.layer = layer;\n\n\tif (!layer || !layer.nodeType) {\n\t\tthrow new TypeError('Layer must be a document node');\n\t}\n\n\t/** @type function() */\n\tthis.onClick = function() { FastClick.prototype.onClick.apply(self, arguments); };\n\n\t/** @type function() */\n\tthis.onTouchStart = function() { FastClick.prototype.onTouchStart.apply(self, arguments); };\n\n\t/** @type function() */\n\tthis.onTouchMove = function() { FastClick.prototype.onTouchMove.apply(self, arguments); };\n\n\t/** @type function() */\n\tthis.onTouchEnd = function() { FastClick.prototype.onTouchEnd.apply(self, arguments); };\n\n\t/** @type function() */\n\tthis.onTouchCancel = function() { FastClick.prototype.onTouchCancel.apply(self, arguments); };\n\n\t// Devices that don't support touch don't need FastClick\n\tif (typeof window.ontouchstart === 'undefined') {\n\t\treturn;\n\t}\n\n\t// Set up event handlers as required\n\tlayer.addEventListener('click', this.onClick, true);\n\tlayer.addEventListener('touchstart', this.onTouchStart, false);\n\tlayer.addEventListener('touchmove', this.onTouchMove, false);\n\tlayer.addEventListener('touchend', this.onTouchEnd, false);\n\tlayer.addEventListener('touchcancel', this.onTouchCancel, false);\n\n\t// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)\n\t// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick\n\t// layer when they are cancelled.\n\tif (!Event.prototype.stopImmediatePropagation) {\n\t\tlayer.addEventListener = function(type, callback, capture) {\n\t\t\tNode.prototype.addEventListener.call(layer, type, function(event) {\n\t\t\t\tif (!event.propagationStopped) {\n\t\t\t\t\tcallback(event);\n\t\t\t\t}\n\t\t\t}, capture);\n\t\t};\n\t}\n\n\t// If a handler is already declared in the element's onclick attribute, it will be fired before\n\t// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and\n\t// adding it as listener.\n\tif (typeof layer.onclick === 'function') {\n\n\t\t// Android browser on at least 3.2 requires a new reference to the function in layer.onclick\n\t\t// - the old one won't work if passed to addEventListener directly.\n\t\toldOnClick = layer.onclick;\n\t\tlayer.addEventListener('click', function(event) {\n\t\t\toldOnClick(event);\n\t\t}, false);\n\t\tlayer.onclick = null;\n\t}\n}\n\n\n/**\n * Android requires an exception for labels.\n *\n * @type boolean\n */\nFastClick.prototype.deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0;\n\n\n/**\n * Determine whether a given element requires a native click.\n *\n * @param {EventTarget|Element} target Target DOM element\n * @returns {boolean} Returns true if the element needs a native click\n */\nFastClick.prototype.needsClick = function(target) {\n\t'use strict';\n\tswitch (target.nodeName.toLowerCase()) {\n\tcase 'label':\n\tcase 'video':\n\t\treturn true;\n\tdefault:\n\t\treturn (/\\bneedsclick\\b/).test(target.className);\n\t}\n};\n\n\n/**\n * Determine whether a given element requires a call to focus to simulate click into element.\n *\n * @param {EventTarget|Element} target Target DOM element\n * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.\n */\nFastClick.prototype.needsFocus = function(target) {\n\t'use strict';\n\tswitch (target.nodeName.toLowerCase()) {\n\tcase 'textarea':\n\tcase 'select':\n\t\treturn true;\n\tcase 'input':\n\t\tswitch (target.type) {\n\t\tcase 'button':\n\t\tcase 'checkbox':\n\t\tcase 'file':\n\t\tcase 'image':\n\t\tcase 'radio':\n\t\tcase 'submit':\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\tdefault:\n\t\treturn (/\\bneedsfocus\\b/).test(target.className);\n\t}\n};\n\n\n/**\n * Send a click event to the specified element.\n *\n * @param {EventTarget|Element} targetElement\n * @param {Event} event\n */\nFastClick.prototype.sendClick = function(targetElement, event) {\n\t'use strict';\n\tvar clickEvent, touch;\n\n\t// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)\n\tif (document.activeElement && document.activeElement !== targetElement) {\n\t\tdocument.activeElement.blur();\n\t}\n\n\ttouch = event.changedTouches[0];\n\n\t// Synthesise a click event, with an extra attribute so it can be tracked\n\tclickEvent = document.createEvent('MouseEvents');\n\tclickEvent.initMouseEvent('click', true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);\n\tclickEvent.forwardedTouchEvent = true;\n\ttargetElement.dispatchEvent(clickEvent);\n};\n\n\n/**\n * On touch start, record the position and scroll offset.\n *\n * @param {Event} event\n * @returns {boolean}\n */\nFastClick.prototype.onTouchStart = function(event) {\n\t'use strict';\n\tvar touch = event.targetTouches[0];\n\n\tthis.trackingClick = true;\n\tthis.trackingClickStart = event.timeStamp;\n\tthis.targetElement = event.target;\n\n\tthis.touchStartX = touch.pageX;\n\tthis.touchStartY = touch.pageY;\n\n\t// Prevent phantom clicks on fast double-tap (issue #36)\n\tif ((event.timeStamp - this.lastClickTime) < 200) {\n\t\tevent.preventDefault();\n\t}\n\n\treturn true;\n};\n\n\n/**\n * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.\n *\n * @param {Event} event\n * @returns {boolean}\n */\nFastClick.prototype.touchHasMoved = function(event) {\n\t'use strict';\n\tvar touch = event.targetTouches[0];\n\n\tif (Math.abs(touch.pageX - this.touchStartX) > 10 || Math.abs(touch.pageY - this.touchStartY) > 10) {\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\n\n/**\n * Update the last position.\n *\n * @param {Event} event\n * @returns {boolean}\n */\nFastClick.prototype.onTouchMove = function(event) {\n\t'use strict';\n\tif (!this.trackingClick) {\n\t\treturn true;\n\t}\n\n\t// If the touch has moved, cancel the click tracking\n\tif (this.targetElement !== event.target || this.touchHasMoved(event)) {\n\t\tthis.trackingClick = false;\n\t\tthis.targetElement = null;\n\t}\n\n\treturn true;\n};\n\n\n/**\n * Attempt to find the labelled control for the given label element.\n *\n * @param {EventTarget|HTMLLabelElement} labelElement\n * @returns {Element|null}\n */\nFastClick.prototype.findControl = function(labelElement) {\n\t'use strict';\n\n\t// Fast path for newer browsers supporting the HTML5 control attribute\n\tif (labelElement.control !== undefined) {\n\t\treturn labelElement.control;\n\t}\n\n\t// All browsers under test that support touch events also support the HTML5 htmlFor attribute\n\tif (labelElement.htmlFor) {\n\t\treturn document.getElementById(labelElement.htmlFor);\n\t}\n\n\t// If no for attribute exists, attempt to retrieve the first labellable descendant element\n\t// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label\n\treturn labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');\n};\n\n\n/**\n * On touch end, determine whether to send a click event at once.\n *\n * @param {Event} event\n * @returns {boolean}\n */\nFastClick.prototype.onTouchEnd = function(event) {\n\t'use strict';\n\tvar forElement, trackingClickStart, targetElement = this.targetElement;\n\n\tif (!this.trackingClick) {\n\t\treturn true;\n\t}\n\n\t// Prevent phantom clicks on fast double-tap (issue #36)\n\tif ((event.timeStamp - this.lastClickTime) < 200) {\n\t\tthis.cancelNextClick = true;\n\t\treturn true;\n\t}\n\n\tthis.lastClickTime = event.timeStamp;\n\n\ttrackingClickStart = this.trackingClickStart;\n\tthis.trackingClick = false;\n\tthis.trackingClickStart = 0;\n\n\tif (targetElement.nodeName.toLowerCase() === 'label') {\n\t\tforElement = this.findControl(targetElement);\n\t\tif (forElement) {\n\t\t\ttargetElement.focus();\n\t\t\tif (this.deviceIsAndroid) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (!this.needsClick(forElement)) {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tthis.sendClick(forElement, event);\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\t} else if (this.needsFocus(targetElement)) {\n\n\t\t// If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.\n\t\tif ((event.timeStamp - trackingClickStart) > 100) {\n\t\t\tthis.targetElement = null;\n\t\t\treturn true;\n\t\t}\n\n\t\ttargetElement.focus();\n\n\t\t// Select elements need the event to go through at least on iOS, otherwise the selector menu won't open.\n\t\tif (targetElement.tagName.toLowerCase() !== 'select') {\n\t\t\tthis.targetElement = null;\n\t\t\tevent.preventDefault();\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t// Prevent the actual click from going though - unless the target node is marked as requiring\n\t// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.\n\tif (!this.needsClick(targetElement)) {\n\t\tevent.preventDefault();\n\t\tthis.sendClick(targetElement, event);\n\t}\n\n\treturn false;\n};\n\n\n/**\n * On touch cancel, stop tracking the click.\n *\n * @returns {void}\n */\nFastClick.prototype.onTouchCancel = function() {\n\t'use strict';\n\tthis.trackingClick = false;\n\tthis.targetElement = null;\n};\n\n\n/**\n * On actual clicks, determine whether this is a touch-generated click, a click action occurring\n * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or\n * an actual click which should be permitted.\n *\n * @param {Event} event\n * @returns {boolean}\n */\nFastClick.prototype.onClick = function(event) {\n\t'use strict';\n\n\tvar oldTargetElement;\n\n\t// If a target element was never set (because a touch event was never fired) allow the click\n\tif (!this.targetElement) {\n\t\treturn true;\n\t}\n\n\tif (event.forwardedTouchEvent) {\n\t\treturn true;\n\t}\n\n\toldTargetElement = this.targetElement;\n\tthis.targetElement = null;\n\n\t// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.\n\tif (this.trackingClick) {\n\t\tthis.trackingClick = false;\n\t\treturn true;\n\t}\n\n\t// Programmatically generated events targeting a specific element should be permitted\n\tif (!event.cancelable) {\n\t\treturn true;\n\t}\n\n\t// Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.\n\tif (event.target.type === 'submit' && event.detail === 0) {\n\t\treturn true;\n\t}\n\n\t// Derive and check the target element to see whether the click needs to be permitted;\n\t// unless explicitly enabled, prevent non-touch click events from triggering actions,\n\t// to prevent ghost/doubleclicks.\n\tif (!this.needsClick(oldTargetElement) || this.cancelNextClick) {\n\t\tthis.cancelNextClick = false;\n\n\t\t// Prevent any user-added listeners declared on FastClick element from being fired.\n\t\tif (event.stopImmediatePropagation) {\n\t\t\tevent.stopImmediatePropagation();\n\t\t} else {\n\n\t\t\t// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)\n\t\t\tevent.propagationStopped = true;\n\t\t}\n\n\t\t// Cancel the event\n\t\tevent.stopPropagation();\n\t\tevent.preventDefault();\n\n\t\treturn false;\n\t}\n\n\t// If clicks are permitted, return true for the action to go through.\n\treturn true;\n};\n\n\n/**\n * Remove all FastClick's event listeners.\n *\n * @returns {void}\n */\nFastClick.prototype.destroy = function() {\n\t'use strict';\n\tvar layer = this.layer;\n\n\tlayer.removeEventListener('click', this.onClick, true);\n\tlayer.removeEventListener('touchstart', this.onTouchStart, false);\n\tlayer.removeEventListener('touchmove', this.onTouchMove, false);\n\tlayer.removeEventListener('touchend', this.onTouchEnd, false);\n\tlayer.removeEventListener('touchcancel', this.onTouchCancel, false);\n};\n\n\nif (typeof define !== 'undefined' && define.amd) {\n\n\t// AMD. Register as an anonymous module.\n\tdefine(function() {\n\t\t'use strict';\n\t\treturn FastClick;\n\t});\n}\n\nif (typeof module !== 'undefined' && module.exports) {\n\tmodule.exports = function(layer) {\n\t\t'use strict';\n\t\treturn new FastClick(layer);\n\t};\n\n\tmodule.exports.FastClick = FastClick;\n}\n\n//@ sourceURL=/node_modules/fastclick/lib/fastclick.js"
));

require.define("/node_modules/routes/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/routes/package.json"
));

require.define("/node_modules/routes/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nvar localRoutes = [];\n\n\n/**\n * Convert path to route object\n *\n * A string or RegExp should be passed,\n * will return { re, src, keys} obj\n *\n * @param  {String / RegExp} path\n * @return {Object}\n */\n\nvar Route = function(path){\n  //using 'new' is optional\n\n  var src, re, keys = [];\n\n  if(path instanceof RegExp){\n    re = path;\n    src = path.toString();\n  }else{\n    re = pathToRegExp(path, keys);\n    src = path;\n  }\n\n  return {\n  \t re: re,\n  \t src: path.toString(),\n  \t keys: keys\n  }\n};\n\n/**\n * Normalize the given path string,\n * returning a regular expression.\n *\n * An empty array should be passed,\n * which will contain the placeholder\n * key names. For example \"/user/:id\" will\n * then contain [\"id\"].\n *\n * @param  {String} path\n * @param  {Array} keys\n * @return {RegExp}\n */\nvar pathToRegExp = function (path, keys) {\n\tpath = path\n\t\t.concat('/?')\n\t\t.replace(/\\/\\(/g, '(?:/')\n\t\t.replace(/(\\/)?(\\.)?:(\\w+)(?:(\\(.*?\\)))?(\\?)?/g, function(_, slash, format, key, capture, optional){\n\t\t\tkeys.push(key);\n\t\t\tslash = slash || '';\n\t\t\treturn ''\n\t\t\t\t+ (optional ? '' : slash)\n\t\t\t\t+ '(?:'\n\t\t\t\t+ (optional ? slash : '')\n\t\t\t\t+ (format || '') + (capture || '([^/]+?)') + ')'\n\t\t\t\t+ (optional || '');\n\t\t})\n\t\t.replace(/([\\/.])/g, '\\\\$1')\n\t\t.replace(/\\*/g, '(.+)');\n\treturn new RegExp('^' + path + '$', 'i');\n};\n\n/**\n * Attempt to match the given request to\n * one of the routes. When successful\n * a  {fn, params, splats} obj is returned\n *\n * @param  {Array} routes\n * @param  {String} uri\n * @return {Object}\n */\nvar match = function (routes, uri) {\n\tvar captures, i = 0;\n\n\tfor (var len = routes.length; i < len; ++i) {\n\t\tvar route = routes[i],\n\t\t    re = route.re,\n\t\t    keys = route.keys,\n\t\t    splats = [],\n\t\t    params = {};\n\n\t\tif (captures = re.exec(uri)) {\n\t\t\tfor (var j = 1, len = captures.length; j < len; ++j) {\n\t\t\t\tvar key = keys[j-1],\n\t\t\t\t\tval = typeof captures[j] === 'string'\n\t\t\t\t\t\t? decodeURIComponent(captures[j])\n\t\t\t\t\t\t: captures[j];\n\t\t\t\tif (key) {\n\t\t\t\t\tparams[key] = val;\n\t\t\t\t} else {\n\t\t\t\t\tsplats.push(val);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tparams: params,\n\t\t\t\tsplats: splats,\n\t\t\t\troute: route.src\n\t\t\t};\n\t\t}\n\t}\n};\n\n/**\n * Default \"normal\" router constructor.\n * accepts path, fn tuples via addRoute\n * returns {fn, params, splats, route}\n *  via match\n *\n * @return {Object}\n */\n\nvar Router = function(){\n  //using 'new' is optional\n  return {\n    routes: [],\n    routeMap : {},\n    addRoute: function(path, fn){\n      if (!path) throw new Error(' route requires a path');\n      if (!fn) throw new Error(' route ' + src + ' requires a callback');\n\n      var route = Route(path);\n      route.fn = fn;\n\n      this.routes.push(route);\n      this.routeMap[path] = fn;\n    },\n\n    match: function(pathname){\n      var route = match(this.routes, pathname);\n      if(route) {\n        route.fn = this.routeMap[route.route];\n      }\n      return route;\n    }\n  }\n};\n\nmodule.exports = {\n  Route: Route,\n  pathToRegExp: pathToRegExp,\n  match: match,\n  Router: Router\n}\n\n//@ sourceURL=/node_modules/routes/index.js"
));

require.define("/www/js/app/config.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var config = module.exports = {\n    t : {}, dbName : \"mydb\",\n    dbHost : 'http://lite.couchbase.'\n  },\n  mu = require(\"mustache\"),\n  coax = require(\"coax\");\n\n// todo make configurable in-app\nconfig.syncOrigin = 'http://mineral.local:4984/';\nconfig.syncTarget = 'http://mineral.local:4984/chat';\n\nconfig.dbUrl = config.dbHost + '/' + config.dbName;\n\nconfig.db = coax(config.dbUrl);\nconfig.dbServer = coax(config.dbHost);\n\n$('script[type=\"text/mustache\"]').each(function() {\n    var id = this.id.split('-');\n    id.pop();\n    module.exports.t[id.join('-')] = mu.compile(this.innerHTML.replace(/^\\s+|\\s+$/g,''));\n});\n\nvar ddoc = {\n  _id : \"_design/threads\",\n  views : {\n    messages : {\n      map : function(doc) {\n        if (doc.type ==\"chat\" && doc.channel_id) {\n          emit([doc.channel_id, doc.created_at],\n            [doc.author, doc.markdown, !!doc._attachments, doc.style == \"announcement\"]);\n        }\n      }.toString(),\n      reduce : function(ks, vs, rr) {\n        var v, d, max, count = 0, lastSender;\n        if (rr) {\n          for (var i = 0; i < vs.length; i++) {\n            v = vs[i];\n            count += v[1];\n            d = new Date(v[0]);\n            if (!max || d > max) {\n              max = d;\n              lastSender = v[2];\n            }\n          };\n        } else {\n          max = new Date(ks[ks.length-1][1]);\n          lastSender = vs[vs.length-1][0];\n          count = vs.length;\n        }\n        return [max, count, lastSender];\n      }.toString()\n    },\n    users : {\n      map : function(doc){\n        if (doc.type == \"profile\") {\n          var key = doc._id.replace(/^profile:/,''), name = doc.nick || key;\n          emit(key, name);\n        }\n      }.toString()\n    }\n  }\n}\n\nconfig.log = function(a, b) {\n  if (typeof a == \"string\") {\n    return console.log(a, JSON.stringify(b))\n  }\n  console.log(JSON.stringify(arguments))\n}\n\nconfig.setup = function(done) {\n  // install the views\n  config.db.put(function(err, ok){\n    if (err.status != 412) throw(JSON.stringify(err));\n    config.db.forceSave(ddoc, done);\n  })\n}\n\n//@ sourceURL=/www/js/app/config.js"
));

require.define("/www/js/app/controller.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var config = require('./config'),\n  db = config.db,\n  messagesView = db([\"_design\",\"threads\",\"_view\",\"messages\"]),\n  usersView = db([\"_design\",\"threads\",\"_view\",\"users\"]),\n  async = require(\"async\"),\n  jsonform = require(\"./jsonform\");\n\n\nexports[\"/\"] = function () {\n  // render index content html\n  var elem = $(this);\n  window.changesPainter = function() {\n    exports[\"/\"].apply(elem);\n  };\n  messagesView({group_level : 1}, function(err, view) {\n    console.log(['sort these', view.rows]);\n    var rows = view.rows.sort(function(a, b){ return new Date(b.value[0]) - new Date(a.value[0])});\n    async.map(rows, function(row, cb) {\n      config.db.get(row.key[0], function(err, doc){\n        row.doc = doc;\n        cb(err, row);\n      });\n    }, function(err, results){\n      elem.html(config.t.index({user: window.email, rows : results}));\n    });\n  });\n};\n\n// $.ajax({url:\"http://lite.couchbase./mydb/dide17d761gi\",success:console.log})\nexports[\"/rooms/new\"] = function () {\n  window.changesPainter = function(){};\n  var elem = $(this);\n  usersView(function(err, view){\n    var rows = [];\n    for (var i = 0; i < view.rows.length; i++) {\n      if (view.rows[i].id !== \"profile:\"+window.email) {\n        rows.push(view.rows[i]);\n      }\n    };\n    elem.html(config.t.newRoom({rows:rows}));\n    elem.find(\"form\").submit(function(e) {\n      e.preventDefault();\n      var doc = jsonform(this);\n      doc.title = doc.title || new Date();\n      doc.members = doc.members || [];\n      if (!Array.isArray(doc.members)) {\n        doc.members = [doc.members];\n      }\n      doc.owners = [window.email];\n      doc.created_at = doc.updated_at = new Date();\n      doc._id = doc.channel_id = Math.random().toString(20).slice(2);\n      doc.type = \"room\";\n      db.post(doc, function(err, ok) {\n        var announce = {\n          type : \"chat\",\n          created_at : new Date(),\n          author : window.email,\n          channel_id : ok.id,\n          style : \"announcement\",\n          markdown : window.email+\" started this room and invited \"+doc.members.join(', ')+\".\"\n        };\n        db.post(announce, function(err, ok) {\n          location.hash = \"/rooms/\"+doc._id;\n        });\n      });\n      return false;\n    });\n  });\n}\n\nexports[\"/rooms/:id\"] = function(params) {\n  var elem = $(this);\n  db.get(params.id, function(err, room) {\n    if(err){return location.hash=\"/error\";}\n    elem.html(config.t.room(room));\n    elem.find(\"form\").submit(makeNewMessageSubmit(window.email));\n    elem.find(\"a.photo\").click(makeNewPhotoClick(window.email));\n    window.changesPainter = function(){\n      listMessages(elem.find(\".messages\"), params.id);\n    };\n    window.changesPainter();\n  });\n};\n\nfunction listMessages (elem, room_id) {\n  messagesView([{descending:true, reduce: false, limit:50,\n      startkey : [room_id,{}], endkey : [room_id]}], function(err, view) {\n    if(err){return console.log([\"listMessages err\", err])}\n    // console.log(view)\n    var row, rows = view.rows;\n    for (var i = 0; i < rows.length; i++) {\n      row = rows[i];\n      if (row.value[0] == window.email) {\n        row.who = \"mine\";\n      }\n      if (row.value[2]) {\n        row.photo = db([row.id, \"picture\"]).pax.toString();\n      }\n    };\n    elem.html(config.t.listMessages(view));\n  });\n}\n\nfunction messageFromForm(author, form) {\n  var doc = jsonform(form);\n  doc.author = author;\n  doc.created_at = doc.updated_at = new Date();\n  // doc.seq = last_seq++;\n  doc.type = \"chat\";\n  return doc;\n};\n\nfunction makeNewMessageSubmit(email) {\n  return function(e) {\n    e.preventDefault();\n    var form = this, doc = messageFromForm(email, form);\n    db.post(doc, function(err, ok){\n      if (err) {\n        return console.log([\"form error\",err]);\n      }\n      // clear the form unless they started typing something new already\n      var input = $(form).find(\"[name=markdown]\");\n      if (input.val() == doc.markdown) {\n        input.val('');\n      }\n    });\n  }\n}\n\nfunction makeNewPhotoClick(email) {\n    return function(e) {\n      e.preventDefault();\n      if (!(navigator.camera && navigator.camera.getPicture)) {\n        console.error(\"no navigator.camera.getPicture\")\n      } else {\n        var link = this, form = $(link).parent(\"form\"),\n          doc = messageFromForm(email, form);\n        navigator.camera.getPicture(function(picData){\n          doc._attachments = {\n            \"picture\" : {\n              content_type : \"image/jpg\",\n              data : picData\n            }\n          };\n          db.post(doc, function(err, ok){\n            if (err) {return console.log(\"save err\",err);}\n            var input = $(\"form.message [name=markdown]\");\n            if (input.val() == doc.markdown) {\n              input.val('');\n            }\n          });\n        }, function(err){\n          console.error([\"camera err\",err]);\n          $(link).text(\"Error\");\n        }, {\n          quality : 25,\n          targetWidth : 1024,\n          targetHeight : 1024,\n          destinationType: Camera.DestinationType.DATA_URL\n        });\n      }\n    }\n};\n\n//@ sourceURL=/www/js/app/controller.js"
));

require.define("/www/js/app/jsonform.js",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = function(elem) {\n  var o = {}, list = $(elem).serializeArray();\n  for (var i = list.length - 1; i >= 0; i--) {\n    var name = list[i].name, value = list[i].value;\n    if (o[name]) {\n        if (!o[name].push) {\n            o[name] = [o[name]];\n        }\n        o[name].push(value);\n    } else {\n        o[name] = value;\n    }\n  };\n  return o;\n};\n\n\n\n//@ sourceURL=/www/js/app/jsonform.js"
));

require.define("/www/js/app/sync.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var config = require(\"./config\"),\n  coax = require(\"coax\");\n\nfunction refreshSync(rep, cb) {\n  var cancel = JSON.parse(JSON.stringify(rep));\n  cancel.cancel = true;\n  coax.post([config.dbHost, \"_replicate\"], cancel, function(err) {\n    if (err) {\n      config.log(\"nothing to cancel\", err)\n    }\n    coax.post([config.dbHost, \"_replicate\"], rep, cb)\n  })\n}\n\nvar pullRep = {\n    source : {url : config.syncTarget},\n    target : config.dbName\n    , continuous : true\n  },\n  pushRep = {\n    target : {url: config.syncTarget},\n    source : config.dbName\n    , continuous : true\n  };\n\n// poll _active_tasks until timeout\n// if success cancel poll, cb no error\n// if needsLogin cancel poll, cb with error\n// if timeout cancel poll, cb with error\n\nfunction parseActiveTasks(body, id) {\n  var row, rows = [], lines = body.split(/\\n/);\n  for (var i = 0; i < lines.length; i++) {\n    if (lines[i]) {\n      try {\n        row = JSON.parse(lines[i]);\n        if (row.task == id) {\n          rows.push(row);\n        }\n      } catch (e) {}\n    }\n  };\n  return rows[rows.length-1];\n}\n\nfunction onXHRChange(xhr, cb) {\n  var orsc = xhr._object.onreadystatechange;\n  xhr._object.onreadystatechange = function(){\n    cb.apply(this, arguments);\n    orsc.apply(this, arguments);\n  }\n}\n\nfunction waitForSyncSuccess(timeout, session_id, cb) {\n  var task, done = false;\n  var errorTimeout = setTimeout(function() {\n    if (done) return;\n    done = true;\n    cb(\"timeout\", task);\n  }, timeout);\n  var req = config.dbServer.get([\"_active_tasks\", {feed : \"continuous\"}], function(){});\n  onXHRChange(req, function(){\n    if (done) return;\n    var offline = true, needsLogin = true;\n    if (this.responseText) {\n      task = parseActiveTasks(this.responseText, session_id);\n      config.log(\"active task\", task)\n      if (task.status == \"Idle\" || task.status == \"Stopped\") {\n        // todo maybe we are cool with tasks that have Processed > 0 changes\n        offline = false;\n      }\n      if (!task.error || task.error[0] != 401) {\n        needsLogin = false;\n      }\n      if (needsLogin) {\n        clearTimeout(errorTimeout);\n        done = true;\n        cb(\"needsLogin\", task);\n      } else if (!offline) {\n        config.log(\"waitForSyncSuccess\", task)\n        clearTimeout(errorTimeout);\n        done = true;\n        cb(false, task);\n      }\n    }\n  });\n}\n\nfunction loginWithPersona(cb) {\n  window.presentPersonaDialog(config.syncOrigin, function(err, assertion){\n    if (err) return cb(err);\n    config.dbServer.post(\"_persona_assertion\", {assertion:assertion}, cb);\n  })\n}\n\n\nfunction setupLocalUser(info, cb) {\n  config.db.get(\"_local/user\", function(err, user) {\n    if (err && err.error == \"not_found\") {\n      config.db.post({_id : \"_local/user\", email:info.email}, function(err, ok){\n        cb(err, info);\n      });\n    } else {\n      if (user.email !== info.email) {\n        cb(\"This device is already synced for \"+user.email+\". To to change users please uninstall and reinstall.\");\n      } else {\n        cb(false, user);\n      }\n    }\n  });\n};\n\n// takes care of triggering pull and push replication to the cloud.\n// also handles getting a persona assertion if there is an authentication error.\n// is a sync is running it will cancel it and retrigger transparently.\nfunction triggerSync(cb, retries) {\n  if (retries === 0) return cb(\"too many retries\");\n  retries = retries || 3;\n  console.log([\"triggering sync\", retries, pullRep]);\n  refreshSync(pushRep, function(err, ok) {\n    console.log([\"pushRep\", err, ok.session_id])\n    waitForSyncSuccess(5000, ok.session_id, function(err, status){\n      if (err == \"needsLogin\") {\n        loginWithPersona(function(err, info){\n          if (err) return cb(err);\n          console.log([\"personaInfo\", info])\n          setupLocalUser(info, function(err, user){\n            if (err) return cb(err);\n            pullRep.source.auth = {persona:{email:user.email}};\n            pushRep.target.auth = {persona:{email:user.email}};\n            console.log([\"retry with email\", user.email]);\n            triggerSync(cb, retries-1);\n          });\n        });\n      } else if (err) {\n        cb(err);\n      } else {\n        // we are connected, set up pull replication\n        refreshSync(pullRep, function(err, ok) {\n          config.db(\"_local/user\", cb);\n        });\n      }\n    });\n  });\n};\n\nexports.trigger = triggerSync;\n\n//@ sourceURL=/www/js/app/sync.js"
));

require.define("/www/js/routes-element.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var routes = require(\"routes\");\n\nmodule.exports = function(table, element, bubbles) {\n  var match = matcherForTable(table, element);\n  $(window).bind('hashchange', function(){\n    match(location.hash);\n  });\n  $(document.body).on(\"click\", \"a\", function() {\n    var matched = match(this.href);\n    // if bubbles is == false, the #/hash won't change, useful for\n    // state that doesn't need to be linkable or in the history\n    if (matched) {\n      return bubbles;\n    }\n  });\n  return {\n    init : function(path) {\n      console.log(\"init\", location.hash, path);\n      var loc = location.hash.slice(location.hash.indexOf('#')+1),\n        matched = match.test(loc);\n      if (matched) {\n        return match(loc);\n      } else {\n        return match(path||\"/\");\n      }\n    },\n    go : function(path) { // for non-linked state on widgets\n      return match(path);\n    }\n  }\n};\n\nfunction matcherForTable(table, element) {\n  var router = new routes.Router();\n\n  function bindFun(path, fun) {\n    console.log(\"bind path\", path);\n    router.addRoute(path, function() {\n      return fun.apply(element, arguments);\n    }); // ensure this is the element\n  }\n\n  for (var path in table) {\n    if (table[path]) {\n      bindFun(path, table[path])\n    }\n  }\n\n  var matchFun = function(url) {\n    var path = url.slice(url.indexOf('#')+1),\n      matched = router.match(path);\n    console.log([\"match?\", path, matched, matched && matched.route]);\n    if (matched) {\n      matched.fn(matched.params, matched.splats)\n    }\n    return matched;\n  };\n  matchFun.test = function(url) {\n    var path = url.slice(url.indexOf('#')+1);\n    return router.match(path);\n  };\n  return matchFun;\n};\n\n\n\n\n//@ sourceURL=/www/js/routes-element.js"
));

require.define("/www/js/touchlink.js",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = function(root, classname) {\n  classname = classname || \"touch\";\n  var events = [\n    [\"click\",\"removeClass\"],\n    [\"touchstart\",\"addClass\"],\n    [\"touchend\",\"removeClass\"]\n  ];\n  for (var i = events.length - 1; i >= 0; i--) {\n    var on = events[i][0], method = events[i][1];\n    $(root).on(on,\"a\",function(e) {\n      var target = $(e.currentTarget);\n      if (target.attr('href')) {\n        target[method](classname);\n      }\n    });\n  };\n};\n\n//@ sourceURL=/www/js/touchlink.js"
));

require.define("/node_modules/coax/lib/coax.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*\n * coax\n * https://github.com/jchris/coax\n *\n * Copyright (c) 2013 Chris Anderson\n * Licensed under the Apache license.\n */\nvar pax = require(\"pax\"),\n  hoax = require(\"hoax\");\n\nvar coaxPax = pax();\n\ncoaxPax.extend(\"getQuery\", function(params) {\n  params = JSON.parse(JSON.stringify(params));\n  var key, keys = [\"key\", \"startkey\", \"endkey\", \"start_key\", \"end_key\"];\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    if (params[key]) {\n      params[key] = JSON.stringify(params[key]);\n    }\n  }\n  return params;\n});\n\nvar Coax = module.exports = hoax.makeHoax(coaxPax());\n\nCoax.extend(\"changes\", function(opts, cb) {\n  if (typeof opts === \"function\") {\n    cb = opts;\n    opts = {};\n  }\n  var self = this;\n  opts = opts || {};\n  opts.feed = \"longpoll\";\n  opts.since = opts.since || 0;\n  // console.log(\"change opts \"+JSON.stringify(opts));\n  self([\"_changes\", opts], function(err, ok) {\n    if (err && err.code == \"ETIMEDOUT\") {\n      return self.changes(opts, cb); // TODO retry limit?\n    } else if (err) {\n      return cb(err);\n    }\n    ok.results.forEach(function(row){\n      cb(null, row);\n    });\n    opts.since = ok.last_seq + 1;\n    self.changes(opts, cb);\n  });\n});\n\nCoax.extend(\"forceSave\", function(doc, cb) {\n  var api = this(doc._id);\n  api.get(function(err, old) {\n    if (err && err.error !== \"not_found\") {\n      return cb(err);\n    }\n    if (!err) {\n      doc._rev = old._rev;\n    }\n    api.put(doc, cb);\n  });\n});\n\n//@ sourceURL=/node_modules/coax/lib/coax.js"
));

require.define("/www/js/app.js",Function(['require','module','exports','__dirname','__filename','process','global'],"$(function() {\n\n  var config = require('./app/config'),\n    controller = require(\"./app/controller\"),\n    sync = require('./app/sync'),\n    // libraries\n    coax = require(\"coax\"),\n    touchlink = require(\"./touchlink\"),\n    fastclick = require(\"fastclick\"),\n    router = require(\"./routes-element\");\n\n  new fastclick.FastClick(document.body);\n\n  var changesSetup = false;\n  function setupChanges(changesHandler) {\n    if (changesSetup) return;\n    changesSetup = true;\n    config.db(function(err, info){\n      console.log(\"setup changes\",info);\n      config.db.changes({include_docs:true, since:info.update_seq}, function(err, change){\n        if (err) {\n          console.log([\"changes doc err\", err]);\n        } else {\n          // console.log([\"chn\", change])\n          change.doc && changesHandler(change.doc);\n        }\n      });\n    });\n\n  }\n  // start the sync\n  function appInit(cb) {\n    sync.trigger(function(err, user){\n      if (err) {\n        alert(err);\n        return;\n      }\n      if (user && user.email) {\n        window.email = user.email;\n        config.db.put(\"profile:\"+user.email, {type : \"profile\"}, function() {\n          cb(false, user.email);\n        });\n      }\n    });\n  }\n\n  config.setup(function(err, ok){\n    if (err) {\n      return config.log([\"setup erz\",err]);\n    }\n    appInit(function(err, email) {\n      var contentRouter = router(controller, $(\"#content\")[0]);\n      contentRouter.init();\n      setupChanges(function(doc){\n        console.log([\"dbchange\", doc._id, doc.channel_id]);\n        console.log([\"call changesPainter\", window.changesPainter.toString()])\n        window.changesPainter && window.changesPainter();\n        if (doc.channel_id == doc._id) {\n          // workaround for https://github.com/couchbaselabs/sync_gateway/issues/31\n          console.log(\"resync\")\n          sync.trigger(function(){});\n        }\n      });\n    });\n  });\n});\n\n//@ sourceURL=/www/js/app.js"
));
require("/www/js/app.js");
})();
